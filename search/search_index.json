{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.1 Equations of Motion Assuming an idealized system with no air resistance and where the projectile is launched from and lands at the same vertical level, the equations of motion can be derived from Newton\u2019s laws: Horizontal motion (constant velocity): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (uniform acceleration): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Where: \\(v_0\\) is the initial velocity \\(\\theta\\) is the angle of projection \\(g\\) is the acceleration due to gravity \\(t\\) is time 1.2 Time of Flight To find the total time of flight \\(T\\) , set \\(y(T) = 0\\) : \\[ 0 = v_0 \\sin(\\theta) \\cdot T - \\frac{1}{2}gT^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] 1.3 Range Substitute \\(T\\) into the horizontal motion to find the range \\(R\\) : \\[ R = v_0 \\cos(\\theta) \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} \\] Using the identity \\(\\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta)\\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the key equation describing how the range depends on the angle of projection. 2. Analysis of the Range 2.1 Dependence on Angle The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at: \\[ \\theta = 45^\\circ \\] The graph of \\(R(\\theta)\\) is symmetric about \\(\\theta = 45^\\circ\\) , and the same range is achieved by complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ). 2.2 Influence of Parameters Initial velocity: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. Gravitational acceleration: Since \\(R \\propto \\frac{1}{g}\\) , projectiles travel farther in weaker gravitational fields (e.g., on the Moon). 3. Practical Applications 3.1 Uneven Terrain If launch and landing heights differ, the equations become more complex. For example, launching from height \\(h\\) , the vertical motion becomes: \\[ y(t) = h + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Solving for the time when \\(y(t) = 0\\) gives a quadratic equation for \\(t\\) , and the solution can be used to compute the modified range. 3.2 Air Resistance and Wind In realistic scenarios, air resistance introduces drag forces that depend on velocity (e.g., quadratic drag). These must be solved numerically, often using computational methods such as Euler's method or Runge-Kutta. 4. Implementation Below is a Python script that simulates and visualizes the range as a function of projection angle: import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angle_deg): theta = np.radians(angle_deg) return (v0**2 * np.sin(2 * theta)) / g # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) ranges = compute_range(v0, g, angles) # Plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show() # --- Section 5: Limitations and Extensions --- # Limitations: # - The model assumes no air resistance (i.e., vacuum conditions). # - Launch and landing heights are assumed to be equal. # - No spin (Magnus effect) or wind is considered. # Extensions: # - Add air resistance using a velocity-dependent drag force and solve numerically. # - Modify equations for projectiles launched from or landing on different elevations. # - Introduce wind by including horizontal acceleration terms. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles_deg = [15, 30, 45, 60, 75] # angles for (a) velocities = [10, 15, 20, 25, 30] # velocities for (b) fixed_velocity = 20 fixed_angle_deg = 45 def compute_trajectory(v0, angle_deg, g=9.81, air_resistance=False, k=0.1, m=1.0): theta = np.radians(angle_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) if not air_resistance: t_flight = 2 * vy0 / g t = np.linspace(0, t_flight, 300) x = vx0 * t y = vy0 * t - 0.5 * g * t**2 else: # Simplified numerical solution using Euler method dt = 0.01 t, x, y = [0], [0], [0] vx, vy = vx0, vy0 while y[-1] >= 0: v = np.sqrt(vx**2 + vy**2) ax = -k * v * vx / m ay = -g - (k * v * vy / m) vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y.append(y[-1] + vy * dt) t.append(t[-1] + dt) t = np.array(t) x = np.array(x) y = np.array(y) return x, y # Create subplots fig, axs = plt.subplots(3, 1, figsize=(10, 18)) # a) Same velocity, different angles for angle in angles_deg: x, y = compute_trajectory(fixed_velocity, angle) axs[0].plot(x, y, label=f\"{angle}\u00b0\") axs[0].set_title(\"a) Same Velocity, Different Angles\") axs[0].set_xlabel(\"Distance (m)\") axs[0].set_ylabel(\"Height (m)\") axs[0].legend() axs[0].grid(True) # b) Same angle, different velocities for v in velocities: x, y = compute_trajectory(v, fixed_angle_deg) axs[1].plot(x, y, label=f\"{v} m/s\") axs[1].set_title(\"b) Same Angle, Different Velocities\") axs[1].set_xlabel(\"Distance (m)\") axs[1].set_ylabel(\"Height (m)\") axs[1].legend() axs[1].grid(True) # c) With vs Without Air Resistance x_no_air, y_no_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=False) x_air, y_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=True) axs[2].plot(x_no_air, y_no_air, label=\"No Air Resistance\") axs[2].plot(x_air, y_air, label=\"With Air Resistance\") axs[2].set_title(\"c) Air Resistance Effect\") axs[2].set_xlabel(\"Distance (m)\") axs[2].set_ylabel(\"Height (m)\") axs[2].legend() axs[2].grid(True) plt.tight_layout() plt.show() My Colab (Canliy961) Projectile Range vs Angle of Projection Air Resistance","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"Assuming an idealized system with no air resistance and where the projectile is launched from and lands at the same vertical level, the equations of motion can be derived from Newton\u2019s laws: Horizontal motion (constant velocity): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (uniform acceleration): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Where: \\(v_0\\) is the initial velocity \\(\\theta\\) is the angle of projection \\(g\\) is the acceleration due to gravity \\(t\\) is time","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"To find the total time of flight \\(T\\) , set \\(y(T) = 0\\) : \\[ 0 = v_0 \\sin(\\theta) \\cdot T - \\frac{1}{2}gT^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range","text":"Substitute \\(T\\) into the horizontal motion to find the range \\(R\\) : \\[ R = v_0 \\cos(\\theta) \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} \\] Using the identity \\(\\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta)\\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the key equation describing how the range depends on the angle of projection.","title":"1.3 Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-angle","text":"The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at: \\[ \\theta = 45^\\circ \\] The graph of \\(R(\\theta)\\) is symmetric about \\(\\theta = 45^\\circ\\) , and the same range is achieved by complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ).","title":"2.1 Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-influence-of-parameters","text":"Initial velocity: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. Gravitational acceleration: Since \\(R \\propto \\frac{1}{g}\\) , projectiles travel farther in weaker gravitational fields (e.g., on the Moon).","title":"2.2 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-uneven-terrain","text":"If launch and landing heights differ, the equations become more complex. For example, launching from height \\(h\\) , the vertical motion becomes: \\[ y(t) = h + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Solving for the time when \\(y(t) = 0\\) gives a quadratic equation for \\(t\\) , and the solution can be used to compute the modified range.","title":"3.1 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-air-resistance-and-wind","text":"In realistic scenarios, air resistance introduces drag forces that depend on velocity (e.g., quadratic drag). These must be solved numerically, often using computational methods such as Euler's method or Runge-Kutta.","title":"3.2 Air Resistance and Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script that simulates and visualizes the range as a function of projection angle: import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angle_deg): theta = np.radians(angle_deg) return (v0**2 * np.sin(2 * theta)) / g # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) ranges = compute_range(v0, g, angles) # Plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show() # --- Section 5: Limitations and Extensions --- # Limitations: # - The model assumes no air resistance (i.e., vacuum conditions). # - Launch and landing heights are assumed to be equal. # - No spin (Magnus effect) or wind is considered. # Extensions: # - Add air resistance using a velocity-dependent drag force and solve numerically. # - Modify equations for projectiles launched from or landing on different elevations. # - Introduce wind by including horizontal acceleration terms. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles_deg = [15, 30, 45, 60, 75] # angles for (a) velocities = [10, 15, 20, 25, 30] # velocities for (b) fixed_velocity = 20 fixed_angle_deg = 45 def compute_trajectory(v0, angle_deg, g=9.81, air_resistance=False, k=0.1, m=1.0): theta = np.radians(angle_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) if not air_resistance: t_flight = 2 * vy0 / g t = np.linspace(0, t_flight, 300) x = vx0 * t y = vy0 * t - 0.5 * g * t**2 else: # Simplified numerical solution using Euler method dt = 0.01 t, x, y = [0], [0], [0] vx, vy = vx0, vy0 while y[-1] >= 0: v = np.sqrt(vx**2 + vy**2) ax = -k * v * vx / m ay = -g - (k * v * vy / m) vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y.append(y[-1] + vy * dt) t.append(t[-1] + dt) t = np.array(t) x = np.array(x) y = np.array(y) return x, y # Create subplots fig, axs = plt.subplots(3, 1, figsize=(10, 18)) # a) Same velocity, different angles for angle in angles_deg: x, y = compute_trajectory(fixed_velocity, angle) axs[0].plot(x, y, label=f\"{angle}\u00b0\") axs[0].set_title(\"a) Same Velocity, Different Angles\") axs[0].set_xlabel(\"Distance (m)\") axs[0].set_ylabel(\"Height (m)\") axs[0].legend() axs[0].grid(True) # b) Same angle, different velocities for v in velocities: x, y = compute_trajectory(v, fixed_angle_deg) axs[1].plot(x, y, label=f\"{v} m/s\") axs[1].set_title(\"b) Same Angle, Different Velocities\") axs[1].set_xlabel(\"Distance (m)\") axs[1].set_ylabel(\"Height (m)\") axs[1].legend() axs[1].grid(True) # c) With vs Without Air Resistance x_no_air, y_no_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=False) x_air, y_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=True) axs[2].plot(x_no_air, y_no_air, label=\"No Air Resistance\") axs[2].plot(x_air, y_air, label=\"With Air Resistance\") axs[2].set_title(\"c) Air Resistance Effect\") axs[2].set_xlabel(\"Distance (m)\") axs[2].set_ylabel(\"Height (m)\") axs[2].legend() axs[2].grid(True) plt.tight_layout() plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#my-colab-canliy961","text":"Projectile Range vs Angle of Projection Air Resistance","title":"My Colab (Canliy961)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation 1.1 Governing Equation The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) is the angular displacement \\(b\\) is the damping coefficient \\(g\\) is gravitational acceleration \\(L\\) is the length of the pendulum \\(A\\) is the amplitude of the driving force \\(\\omega\\) is the driving frequency 1.2 Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we approximate \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear second-order differential equation describing a damped, driven harmonic oscillator. 1.3 Resonance Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) . At resonance, the system absorbs energy most efficiently, leading to large oscillations (limited only by damping). The steady-state amplitude response \\(\\Theta(\\omega)\\) for the linearized case is: \\[ \\Theta(\\omega) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] This curve demonstrates resonance behavior and is important for identifying the critical driving frequency. 2. Analysis of Dynamics 2.1 Parameter Dependence Damping coefficient ( \\(b\\) ): Controls energy dissipation Low \\(b\\) : resonance peak is sharp High \\(b\\) : oscillations decay quickly, response is flatter Driving amplitude ( \\(A\\) ): Larger \\(A\\) : stronger external influence Can drive the system into nonlinear or chaotic regimes Driving frequency ( \\(\\omega\\) ): If near \\(\\omega_0\\) : resonance Away from \\(\\omega_0\\) : weak or slow oscillations 2.2 Transition to Chaos When the small-angle approximation is no longer valid, the equation becomes nonlinear. For certain values of \\(A\\) , \\(\\omega\\) , and \\(b\\) , the system exhibits: Period doubling Quasiperiodicity Chaotic motion (sensitive dependence on initial conditions) To analyze this, phase portraits and Poincar\u00e9 sections (sampling phase space at intervals of the driving period) are useful. 3. Practical Applications The forced damped pendulum is a model for many systems: Energy harvesting: Mechanical systems coupled to electromagnetic or piezoelectric generators Suspension bridges: Dynamic loads (e.g., wind) may cause resonance Clock mechanisms: Pendulum dynamics must be stabilized for accurate timekeeping Oscillating circuits: Driven RLC circuits act as electrical analogs Biomechanics: Human gait and balance involve pendulum-like dynamics under control 4. Implementation 4.1 Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum(t, y, b, A, omega): theta, omega_theta = y dydt = [omega_theta, -b * omega_theta - np.sin(theta) + A * np.cos(omega * t)] return dydt # Time span and evaluation points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # Initial conditions: small angle, zero initial velocity y0 = [0.2, 0] # Define different scenarios scenarios = { \"Pure Pendulum\": {\"b\": 0.0, \"A\": 0.0, \"omega\": 0.0}, \"Damped Pendulum\": {\"b\": 0.5, \"A\": 0.0, \"omega\": 0.0}, \"Driven Pendulum\": {\"b\": 0.0, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (1)\": {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (2)\": {\"b\": 0.2, \"A\": 0.8, \"omega\": 1.5} } # Solve the ODEs results = {} for name, params in scenarios.items(): sol = solve_ivp(pendulum, t_span, y0, args=(params[\"b\"], params[\"A\"], params[\"omega\"]), t_eval=t_eval) results[name] = sol # Plot phase space plt.figure(figsize=(12, 8)) for name, sol in results.items(): plt.plot(sol.y[0], sol.y[1], label=name) plt.title(\"Phase Space of Pendulum Scenarios\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() 4.2 Pendulum To investigate chaotic dynamics in the forced damped pendulum, we visualize the motion using: Phase Space: Plot of \\(\\theta\\) vs \\(\\frac{d\\theta}{dt}\\) Poincar\u00e9 Section: Discrete samples of the system at each driving period Let the driving period be: \\[ T = \\frac{2\\pi}{\\omega} \\] We sample the pendulum state \\((\\theta, \\dot{\\theta})\\) at times \\(t = nT\\) . # Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time span and time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # 1. Simple Pendulum def simple_pendulum(t, y): theta, omega = y dydt = [omega, -np.sin(theta)] return dydt sol1 = solve_ivp(simple_pendulum, t_span, [0.2, 0], t_eval=t_eval) # 2. Damped Pendulum def damped_pendulum(t, y, gamma=0.1): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta)] return dydt sol2 = solve_ivp(damped_pendulum, t_span, [0.8, 0], t_eval=t_eval) # 3. Forced Pendulum def forced_pendulum(t, y, gamma=0.2, A=1.5, omega_drive=2/3): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol3 = solve_ivp(forced_pendulum, t_span, [0.2, 0], t_eval=t_eval) # Plotting fig, axs = plt.subplots(3, 2, figsize=(12, 12)) # Simple axs[0, 0].plot(sol1.t, sol1.y[0], 'r') axs[0, 0].set_title(\"1) Simple Pendulum\\nTime Series\") axs[0, 1].plot(sol1.y[0], sol1.y[1], 'r') axs[0, 1].set_title(\"Phase Portrait\") # Damped axs[1, 0].plot(sol2.t, sol2.y[0], 'b') axs[1, 0].set_title(\"2) Damped Pendulum\\nTime Series\") axs[1, 1].plot(sol2.y[0], sol2.y[1], 'b') axs[1, 1].set_title(\"Phase Portrait\") # Forced axs[2, 0].plot(sol3.t, sol3.y[0], 'c') axs[2, 0].set_title(\"3) Forced Pendulum\\nTime Series\") axs[2, 1].plot(sol3.y[0], sol3.y[1], 'c') axs[2, 1].set_title(\"Phase Portrait\") for ax in axs.flat: ax.set_xlabel('Time (s)' if 'Time Series' in ax.get_title() else '\u03b8 (rad)') ax.set_ylabel('\u03b8 (rad)' if 'Time Series' in ax.get_title() else '\u03c9 (rad/s)') ax.grid(True) plt.tight_layout() plt.show() My Colab (Canliy961) Pendulum Scenarios Plots1&2&3 Pendulum Plots4&5","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-equation","text":"The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) is the angular displacement \\(b\\) is the damping coefficient \\(g\\) is gravitational acceleration \\(L\\) is the length of the pendulum \\(A\\) is the amplitude of the driving force \\(\\omega\\) is the driving frequency","title":"1.1 Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we approximate \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear second-order differential equation describing a damped, driven harmonic oscillator.","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) . At resonance, the system absorbs energy most efficiently, leading to large oscillations (limited only by damping). The steady-state amplitude response \\(\\Theta(\\omega)\\) for the linearized case is: \\[ \\Theta(\\omega) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] This curve demonstrates resonance behavior and is important for identifying the critical driving frequency.","title":"1.3 Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-parameter-dependence","text":"Damping coefficient ( \\(b\\) ): Controls energy dissipation Low \\(b\\) : resonance peak is sharp High \\(b\\) : oscillations decay quickly, response is flatter Driving amplitude ( \\(A\\) ): Larger \\(A\\) : stronger external influence Can drive the system into nonlinear or chaotic regimes Driving frequency ( \\(\\omega\\) ): If near \\(\\omega_0\\) : resonance Away from \\(\\omega_0\\) : weak or slow oscillations","title":"2.1 Parameter Dependence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-transition-to-chaos","text":"When the small-angle approximation is no longer valid, the equation becomes nonlinear. For certain values of \\(A\\) , \\(\\omega\\) , and \\(b\\) , the system exhibits: Period doubling Quasiperiodicity Chaotic motion (sensitive dependence on initial conditions) To analyze this, phase portraits and Poincar\u00e9 sections (sampling phase space at intervals of the driving period) are useful.","title":"2.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum is a model for many systems: Energy harvesting: Mechanical systems coupled to electromagnetic or piezoelectric generators Suspension bridges: Dynamic loads (e.g., wind) may cause resonance Clock mechanisms: Pendulum dynamics must be stabilized for accurate timekeeping Oscillating circuits: Driven RLC circuits act as electrical analogs Biomechanics: Human gait and balance involve pendulum-like dynamics under control","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum(t, y, b, A, omega): theta, omega_theta = y dydt = [omega_theta, -b * omega_theta - np.sin(theta) + A * np.cos(omega * t)] return dydt # Time span and evaluation points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # Initial conditions: small angle, zero initial velocity y0 = [0.2, 0] # Define different scenarios scenarios = { \"Pure Pendulum\": {\"b\": 0.0, \"A\": 0.0, \"omega\": 0.0}, \"Damped Pendulum\": {\"b\": 0.5, \"A\": 0.0, \"omega\": 0.0}, \"Driven Pendulum\": {\"b\": 0.0, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (1)\": {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (2)\": {\"b\": 0.2, \"A\": 0.8, \"omega\": 1.5} } # Solve the ODEs results = {} for name, params in scenarios.items(): sol = solve_ivp(pendulum, t_span, y0, args=(params[\"b\"], params[\"A\"], params[\"omega\"]), t_eval=t_eval) results[name] = sol # Plot phase space plt.figure(figsize=(12, 8)) for name, sol in results.items(): plt.plot(sol.y[0], sol.y[1], label=name) plt.title(\"Phase Space of Pendulum Scenarios\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"4.1 Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-pendulum","text":"To investigate chaotic dynamics in the forced damped pendulum, we visualize the motion using: Phase Space: Plot of \\(\\theta\\) vs \\(\\frac{d\\theta}{dt}\\) Poincar\u00e9 Section: Discrete samples of the system at each driving period Let the driving period be: \\[ T = \\frac{2\\pi}{\\omega} \\] We sample the pendulum state \\((\\theta, \\dot{\\theta})\\) at times \\(t = nT\\) . # Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time span and time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # 1. Simple Pendulum def simple_pendulum(t, y): theta, omega = y dydt = [omega, -np.sin(theta)] return dydt sol1 = solve_ivp(simple_pendulum, t_span, [0.2, 0], t_eval=t_eval) # 2. Damped Pendulum def damped_pendulum(t, y, gamma=0.1): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta)] return dydt sol2 = solve_ivp(damped_pendulum, t_span, [0.8, 0], t_eval=t_eval) # 3. Forced Pendulum def forced_pendulum(t, y, gamma=0.2, A=1.5, omega_drive=2/3): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol3 = solve_ivp(forced_pendulum, t_span, [0.2, 0], t_eval=t_eval) # Plotting fig, axs = plt.subplots(3, 2, figsize=(12, 12)) # Simple axs[0, 0].plot(sol1.t, sol1.y[0], 'r') axs[0, 0].set_title(\"1) Simple Pendulum\\nTime Series\") axs[0, 1].plot(sol1.y[0], sol1.y[1], 'r') axs[0, 1].set_title(\"Phase Portrait\") # Damped axs[1, 0].plot(sol2.t, sol2.y[0], 'b') axs[1, 0].set_title(\"2) Damped Pendulum\\nTime Series\") axs[1, 1].plot(sol2.y[0], sol2.y[1], 'b') axs[1, 1].set_title(\"Phase Portrait\") # Forced axs[2, 0].plot(sol3.t, sol3.y[0], 'c') axs[2, 0].set_title(\"3) Forced Pendulum\\nTime Series\") axs[2, 1].plot(sol3.y[0], sol3.y[1], 'c') axs[2, 1].set_title(\"Phase Portrait\") for ax in axs.flat: ax.set_xlabel('Time (s)' if 'Time Series' in ax.get_title() else '\u03b8 (rad)') ax.set_ylabel('\u03b8 (rad)' if 'Time Series' in ax.get_title() else '\u03c9 (rad/s)') ax.grid(True) plt.tight_layout() plt.show()","title":"4.2 Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#my-colab-canliy961","text":"Pendulum Scenarios Plots1&2&3 Pendulum Plots4&5","title":"My Colab (Canliy961)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler\u2019s Third Law: Orbital Period and Orbital Radius 1. Theoretical Derivation Kepler\u2019s Third Law (Simplified for Circular Orbits) For a body in a circular orbit around a much more massive body, the gravitational force provides the necessary centripetal force: Gravitational Force: \\(F_{\\text{gravity}} = \\frac{G M m}{r^2}\\) Centripetal Force: \\(F_{\\text{centripetal}} = \\frac{m v^2}{r}\\) Equating both forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is related to velocity \\(v\\) and radius \\(r\\) : \\[ v = \\frac{2\\pi r}{T} \\Rightarrow \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\Rightarrow \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) 2. Astronomical Implications Planetary Mass Determination: If you know a moon's orbit ( \\(T\\) , \\(r\\) ), you can calculate the mass of the planet using: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Interplanetary Distance: Comparing periods and distances of planets allows relative distances from the Sun to be calculated without direct measurements. Satellite Orbit Design: Used to determine the correct altitude for geosynchronous orbits. 3. Real-World Examples Example 1: The Moon Orbiting Earth Radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) Period: \\(T \\approx 27.3 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) Using Kepler\u2019s law, we can estimate Earth\u2019s mass. Example 2: Solar System Planets By plotting \\(\\log(T)\\) vs. \\(\\log(r)\\) for planets, we should get a straight line with slope \\(\\approx 1.5\\) . 4. Computational Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 1.989e30 # Mass of the Sun (kg) # Orbital radii (m) - approximate average values radii = np.array([ 5.79e10, # Mercury 1.08e11, # Venus 1.50e11, # Earth 2.28e11, # Mars 7.78e11, # Jupiter 1.43e12, # Saturn 2.87e12, # Uranus 4.50e12 # Neptune ]) # Compute periods using Kepler's Third Law T = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Plot log(T) vs log(r) plt.figure(figsize=(8,6)) plt.plot(np.log10(radii), np.log10(T), 'o-') plt.xlabel(\"log10(Orbital Radius) [log10(m)]\") plt.ylabel(\"log10(Orbital Period) [log10(s)]\") plt.title(\"Kepler\u2019s Third Law: log-log plot\") plt.grid(True) plt.show() 5. Graphical Representation A circular orbit simulation can be animated using matplotlib.animation . Orbital period data from real planets supports the \\(T^2 \\propto r^3\\) relationship. 6. Extension to Elliptical Orbits Kepler\u2019s Third Law still applies if \\(r\\) is replaced with the semi-major axis \\(a\\) . For elliptical orbits: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This allows for broader applications, including comets, exoplanets, and binary stars.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"","title":"Kepler\u2019s Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Kepler\u2019s Third Law (Simplified for Circular Orbits) For a body in a circular orbit around a much more massive body, the gravitational force provides the necessary centripetal force: Gravitational Force: \\(F_{\\text{gravity}} = \\frac{G M m}{r^2}\\) Centripetal Force: \\(F_{\\text{centripetal}} = \\frac{m v^2}{r}\\) Equating both forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is related to velocity \\(v\\) and radius \\(r\\) : \\[ v = \\frac{2\\pi r}{T} \\Rightarrow \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\Rightarrow \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\)","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"Planetary Mass Determination: If you know a moon's orbit ( \\(T\\) , \\(r\\) ), you can calculate the mass of the planet using: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Interplanetary Distance: Comparing periods and distances of planets allows relative distances from the Sun to be calculated without direct measurements. Satellite Orbit Design: Used to determine the correct altitude for geosynchronous orbits.","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon-orbiting-earth","text":"Radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) Period: \\(T \\approx 27.3 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) Using Kepler\u2019s law, we can estimate Earth\u2019s mass.","title":"Example 1: The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-solar-system-planets","text":"By plotting \\(\\log(T)\\) vs. \\(\\log(r)\\) for planets, we should get a straight line with slope \\(\\approx 1.5\\) .","title":"Example 2: Solar System Planets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 1.989e30 # Mass of the Sun (kg) # Orbital radii (m) - approximate average values radii = np.array([ 5.79e10, # Mercury 1.08e11, # Venus 1.50e11, # Earth 2.28e11, # Mars 7.78e11, # Jupiter 1.43e12, # Saturn 2.87e12, # Uranus 4.50e12 # Neptune ]) # Compute periods using Kepler's Third Law T = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Plot log(T) vs log(r) plt.figure(figsize=(8,6)) plt.plot(np.log10(radii), np.log10(T), 'o-') plt.xlabel(\"log10(Orbital Radius) [log10(m)]\") plt.ylabel(\"log10(Orbital Period) [log10(s)]\") plt.title(\"Kepler\u2019s Third Law: log-log plot\") plt.grid(True) plt.show()","title":"4. Computational Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-graphical-representation","text":"A circular orbit simulation can be animated using matplotlib.animation . Orbital period data from real planets supports the \\(T^2 \\propto r^3\\) relationship.","title":"5. Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law still applies if \\(r\\) is replaced with the semi-major axis \\(a\\) . For elliptical orbits: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This allows for broader applications, including comets, exoplanets, and binary stars.","title":"6. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}