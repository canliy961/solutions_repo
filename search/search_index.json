{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.1 Equations of Motion Assuming an idealized system with no air resistance and where the projectile is launched from and lands at the same vertical level, the equations of motion can be derived from Newton\u2019s laws: Horizontal motion (constant velocity): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (uniform acceleration): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Where: \\(v_0\\) is the initial velocity \\(\\theta\\) is the angle of projection \\(g\\) is the acceleration due to gravity \\(t\\) is time 1.2 Time of Flight To find the total time of flight \\(T\\) , set \\(y(T) = 0\\) : \\[ 0 = v_0 \\sin(\\theta) \\cdot T - \\frac{1}{2}gT^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] 1.3 Range Substitute \\(T\\) into the horizontal motion to find the range \\(R\\) : \\[ R = v_0 \\cos(\\theta) \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} \\] Using the identity \\(\\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta)\\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the key equation describing how the range depends on the angle of projection. 2. Analysis of the Range 2.1 Dependence on Angle The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at: \\[ \\theta = 45^\\circ \\] The graph of \\(R(\\theta)\\) is symmetric about \\(\\theta = 45^\\circ\\) , and the same range is achieved by complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ). 2.2 Influence of Parameters Initial velocity: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. Gravitational acceleration: Since \\(R \\propto \\frac{1}{g}\\) , projectiles travel farther in weaker gravitational fields (e.g., on the Moon). 3. Practical Applications 3.1 Uneven Terrain If launch and landing heights differ, the equations become more complex. For example, launching from height \\(h\\) , the vertical motion becomes: \\[ y(t) = h + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Solving for the time when \\(y(t) = 0\\) gives a quadratic equation for \\(t\\) , and the solution can be used to compute the modified range. 3.2 Air Resistance and Wind In realistic scenarios, air resistance introduces drag forces that depend on velocity (e.g., quadratic drag). These must be solved numerically, often using computational methods such as Euler's method or Runge-Kutta. 4. Implementation Below is a Python script that simulates and visualizes the range as a function of projection angle: import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angle_deg): theta = np.radians(angle_deg) return (v0**2 * np.sin(2 * theta)) / g # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) ranges = compute_range(v0, g, angles) # Plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show() # --- Section 5: Limitations and Extensions --- # Limitations: # - The model assumes no air resistance (i.e., vacuum conditions). # - Launch and landing heights are assumed to be equal. # - No spin (Magnus effect) or wind is considered. # Extensions: # - Add air resistance using a velocity-dependent drag force and solve numerically. # - Modify equations for projectiles launched from or landing on different elevations. # - Introduce wind by including horizontal acceleration terms. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles_deg = [15, 30, 45, 60, 75] # angles for (a) velocities = [10, 15, 20, 25, 30] # velocities for (b) fixed_velocity = 20 fixed_angle_deg = 45 def compute_trajectory(v0, angle_deg, g=9.81, air_resistance=False, k=0.1, m=1.0): theta = np.radians(angle_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) if not air_resistance: t_flight = 2 * vy0 / g t = np.linspace(0, t_flight, 300) x = vx0 * t y = vy0 * t - 0.5 * g * t**2 else: # Simplified numerical solution using Euler method dt = 0.01 t, x, y = [0], [0], [0] vx, vy = vx0, vy0 while y[-1] >= 0: v = np.sqrt(vx**2 + vy**2) ax = -k * v * vx / m ay = -g - (k * v * vy / m) vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y.append(y[-1] + vy * dt) t.append(t[-1] + dt) t = np.array(t) x = np.array(x) y = np.array(y) return x, y # Create subplots fig, axs = plt.subplots(3, 1, figsize=(10, 18)) # a) Same velocity, different angles for angle in angles_deg: x, y = compute_trajectory(fixed_velocity, angle) axs[0].plot(x, y, label=f\"{angle}\u00b0\") axs[0].set_title(\"a) Same Velocity, Different Angles\") axs[0].set_xlabel(\"Distance (m)\") axs[0].set_ylabel(\"Height (m)\") axs[0].legend() axs[0].grid(True) # b) Same angle, different velocities for v in velocities: x, y = compute_trajectory(v, fixed_angle_deg) axs[1].plot(x, y, label=f\"{v} m/s\") axs[1].set_title(\"b) Same Angle, Different Velocities\") axs[1].set_xlabel(\"Distance (m)\") axs[1].set_ylabel(\"Height (m)\") axs[1].legend() axs[1].grid(True) # c) With vs Without Air Resistance x_no_air, y_no_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=False) x_air, y_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=True) axs[2].plot(x_no_air, y_no_air, label=\"No Air Resistance\") axs[2].plot(x_air, y_air, label=\"With Air Resistance\") axs[2].set_title(\"c) Air Resistance Effect\") axs[2].set_xlabel(\"Distance (m)\") axs[2].set_ylabel(\"Height (m)\") axs[2].legend() axs[2].grid(True) plt.tight_layout() plt.show() My Colab (Canliy961) Projectile Range vs Angle of Projection Air Resistance","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"Assuming an idealized system with no air resistance and where the projectile is launched from and lands at the same vertical level, the equations of motion can be derived from Newton\u2019s laws: Horizontal motion (constant velocity): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (uniform acceleration): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Where: \\(v_0\\) is the initial velocity \\(\\theta\\) is the angle of projection \\(g\\) is the acceleration due to gravity \\(t\\) is time","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"To find the total time of flight \\(T\\) , set \\(y(T) = 0\\) : \\[ 0 = v_0 \\sin(\\theta) \\cdot T - \\frac{1}{2}gT^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range","text":"Substitute \\(T\\) into the horizontal motion to find the range \\(R\\) : \\[ R = v_0 \\cos(\\theta) \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} \\] Using the identity \\(\\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta)\\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the key equation describing how the range depends on the angle of projection.","title":"1.3 Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-angle","text":"The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at: \\[ \\theta = 45^\\circ \\] The graph of \\(R(\\theta)\\) is symmetric about \\(\\theta = 45^\\circ\\) , and the same range is achieved by complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ).","title":"2.1 Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-influence-of-parameters","text":"Initial velocity: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. Gravitational acceleration: Since \\(R \\propto \\frac{1}{g}\\) , projectiles travel farther in weaker gravitational fields (e.g., on the Moon).","title":"2.2 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-uneven-terrain","text":"If launch and landing heights differ, the equations become more complex. For example, launching from height \\(h\\) , the vertical motion becomes: \\[ y(t) = h + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Solving for the time when \\(y(t) = 0\\) gives a quadratic equation for \\(t\\) , and the solution can be used to compute the modified range.","title":"3.1 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-air-resistance-and-wind","text":"In realistic scenarios, air resistance introduces drag forces that depend on velocity (e.g., quadratic drag). These must be solved numerically, often using computational methods such as Euler's method or Runge-Kutta.","title":"3.2 Air Resistance and Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script that simulates and visualizes the range as a function of projection angle: import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angle_deg): theta = np.radians(angle_deg) return (v0**2 * np.sin(2 * theta)) / g # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) ranges = compute_range(v0, g, angles) # Plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show() # --- Section 5: Limitations and Extensions --- # Limitations: # - The model assumes no air resistance (i.e., vacuum conditions). # - Launch and landing heights are assumed to be equal. # - No spin (Magnus effect) or wind is considered. # Extensions: # - Add air resistance using a velocity-dependent drag force and solve numerically. # - Modify equations for projectiles launched from or landing on different elevations. # - Introduce wind by including horizontal acceleration terms. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles_deg = [15, 30, 45, 60, 75] # angles for (a) velocities = [10, 15, 20, 25, 30] # velocities for (b) fixed_velocity = 20 fixed_angle_deg = 45 def compute_trajectory(v0, angle_deg, g=9.81, air_resistance=False, k=0.1, m=1.0): theta = np.radians(angle_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) if not air_resistance: t_flight = 2 * vy0 / g t = np.linspace(0, t_flight, 300) x = vx0 * t y = vy0 * t - 0.5 * g * t**2 else: # Simplified numerical solution using Euler method dt = 0.01 t, x, y = [0], [0], [0] vx, vy = vx0, vy0 while y[-1] >= 0: v = np.sqrt(vx**2 + vy**2) ax = -k * v * vx / m ay = -g - (k * v * vy / m) vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y.append(y[-1] + vy * dt) t.append(t[-1] + dt) t = np.array(t) x = np.array(x) y = np.array(y) return x, y # Create subplots fig, axs = plt.subplots(3, 1, figsize=(10, 18)) # a) Same velocity, different angles for angle in angles_deg: x, y = compute_trajectory(fixed_velocity, angle) axs[0].plot(x, y, label=f\"{angle}\u00b0\") axs[0].set_title(\"a) Same Velocity, Different Angles\") axs[0].set_xlabel(\"Distance (m)\") axs[0].set_ylabel(\"Height (m)\") axs[0].legend() axs[0].grid(True) # b) Same angle, different velocities for v in velocities: x, y = compute_trajectory(v, fixed_angle_deg) axs[1].plot(x, y, label=f\"{v} m/s\") axs[1].set_title(\"b) Same Angle, Different Velocities\") axs[1].set_xlabel(\"Distance (m)\") axs[1].set_ylabel(\"Height (m)\") axs[1].legend() axs[1].grid(True) # c) With vs Without Air Resistance x_no_air, y_no_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=False) x_air, y_air = compute_trajectory(fixed_velocity, fixed_angle_deg, air_resistance=True) axs[2].plot(x_no_air, y_no_air, label=\"No Air Resistance\") axs[2].plot(x_air, y_air, label=\"With Air Resistance\") axs[2].set_title(\"c) Air Resistance Effect\") axs[2].set_xlabel(\"Distance (m)\") axs[2].set_ylabel(\"Height (m)\") axs[2].legend() axs[2].grid(True) plt.tight_layout() plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#my-colab-canliy961","text":"Projectile Range vs Angle of Projection Air Resistance","title":"My Colab (Canliy961)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation 1.1 Governing Equation The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) is the angular displacement \\(b\\) is the damping coefficient \\(g\\) is gravitational acceleration \\(L\\) is the length of the pendulum \\(A\\) is the amplitude of the driving force \\(\\omega\\) is the driving frequency 1.2 Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we approximate \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear second-order differential equation describing a damped, driven harmonic oscillator. 1.3 Resonance Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) . At resonance, the system absorbs energy most efficiently, leading to large oscillations (limited only by damping). The steady-state amplitude response \\(\\Theta(\\omega)\\) for the linearized case is: \\[ \\Theta(\\omega) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] This curve demonstrates resonance behavior and is important for identifying the critical driving frequency. 2. Analysis of Dynamics 2.1 Parameter Dependence Damping coefficient ( \\(b\\) ): Controls energy dissipation Low \\(b\\) : resonance peak is sharp High \\(b\\) : oscillations decay quickly, response is flatter Driving amplitude ( \\(A\\) ): Larger \\(A\\) : stronger external influence Can drive the system into nonlinear or chaotic regimes Driving frequency ( \\(\\omega\\) ): If near \\(\\omega_0\\) : resonance Away from \\(\\omega_0\\) : weak or slow oscillations 2.2 Transition to Chaos When the small-angle approximation is no longer valid, the equation becomes nonlinear. For certain values of \\(A\\) , \\(\\omega\\) , and \\(b\\) , the system exhibits: Period doubling Quasiperiodicity Chaotic motion (sensitive dependence on initial conditions) To analyze this, phase portraits and Poincar\u00e9 sections (sampling phase space at intervals of the driving period) are useful. 3. Practical Applications The forced damped pendulum is a model for many systems: Energy harvesting: Mechanical systems coupled to electromagnetic or piezoelectric generators Suspension bridges: Dynamic loads (e.g., wind) may cause resonance Clock mechanisms: Pendulum dynamics must be stabilized for accurate timekeeping Oscillating circuits: Driven RLC circuits act as electrical analogs Biomechanics: Human gait and balance involve pendulum-like dynamics under control 4. Implementation 4.1 Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum(t, y, b, A, omega): theta, omega_theta = y dydt = [omega_theta, -b * omega_theta - np.sin(theta) + A * np.cos(omega * t)] return dydt # Time span and evaluation points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # Initial conditions: small angle, zero initial velocity y0 = [0.2, 0] # Define different scenarios scenarios = { \"Pure Pendulum\": {\"b\": 0.0, \"A\": 0.0, \"omega\": 0.0}, \"Damped Pendulum\": {\"b\": 0.5, \"A\": 0.0, \"omega\": 0.0}, \"Driven Pendulum\": {\"b\": 0.0, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (1)\": {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (2)\": {\"b\": 0.2, \"A\": 0.8, \"omega\": 1.5} } # Solve the ODEs results = {} for name, params in scenarios.items(): sol = solve_ivp(pendulum, t_span, y0, args=(params[\"b\"], params[\"A\"], params[\"omega\"]), t_eval=t_eval) results[name] = sol # Plot phase space plt.figure(figsize=(12, 8)) for name, sol in results.items(): plt.plot(sol.y[0], sol.y[1], label=name) plt.title(\"Phase Space of Pendulum Scenarios\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() 4.2 Pendulum To investigate chaotic dynamics in the forced damped pendulum, we visualize the motion using: Phase Space: Plot of \\(\\theta\\) vs \\(\\frac{d\\theta}{dt}\\) Poincar\u00e9 Section: Discrete samples of the system at each driving period Let the driving period be: \\[ T = \\frac{2\\pi}{\\omega} \\] We sample the pendulum state \\((\\theta, \\dot{\\theta})\\) at times \\(t = nT\\) . # Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time span and time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # 1. Simple Pendulum def simple_pendulum(t, y): theta, omega = y dydt = [omega, -np.sin(theta)] return dydt sol1 = solve_ivp(simple_pendulum, t_span, [0.2, 0], t_eval=t_eval) # 2. Damped Pendulum def damped_pendulum(t, y, gamma=0.1): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta)] return dydt sol2 = solve_ivp(damped_pendulum, t_span, [0.8, 0], t_eval=t_eval) # 3. Forced Pendulum def forced_pendulum(t, y, gamma=0.2, A=1.5, omega_drive=2/3): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol3 = solve_ivp(forced_pendulum, t_span, [0.2, 0], t_eval=t_eval) # Plotting fig, axs = plt.subplots(3, 2, figsize=(12, 12)) # Simple axs[0, 0].plot(sol1.t, sol1.y[0], 'r') axs[0, 0].set_title(\"1) Simple Pendulum\\nTime Series\") axs[0, 1].plot(sol1.y[0], sol1.y[1], 'r') axs[0, 1].set_title(\"Phase Portrait\") # Damped axs[1, 0].plot(sol2.t, sol2.y[0], 'b') axs[1, 0].set_title(\"2) Damped Pendulum\\nTime Series\") axs[1, 1].plot(sol2.y[0], sol2.y[1], 'b') axs[1, 1].set_title(\"Phase Portrait\") # Forced axs[2, 0].plot(sol3.t, sol3.y[0], 'c') axs[2, 0].set_title(\"3) Forced Pendulum\\nTime Series\") axs[2, 1].plot(sol3.y[0], sol3.y[1], 'c') axs[2, 1].set_title(\"Phase Portrait\") for ax in axs.flat: ax.set_xlabel('Time (s)' if 'Time Series' in ax.get_title() else '\u03b8 (rad)') ax.set_ylabel('\u03b8 (rad)' if 'Time Series' in ax.get_title() else '\u03c9 (rad/s)') ax.grid(True) plt.tight_layout() plt.show() My Colab (Canliy961) Pendulum Scenarios Plots1&2&3 Pendulum Plots4&5","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-equation","text":"The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) is the angular displacement \\(b\\) is the damping coefficient \\(g\\) is gravitational acceleration \\(L\\) is the length of the pendulum \\(A\\) is the amplitude of the driving force \\(\\omega\\) is the driving frequency","title":"1.1 Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we approximate \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear second-order differential equation describing a damped, driven harmonic oscillator.","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) . At resonance, the system absorbs energy most efficiently, leading to large oscillations (limited only by damping). The steady-state amplitude response \\(\\Theta(\\omega)\\) for the linearized case is: \\[ \\Theta(\\omega) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] This curve demonstrates resonance behavior and is important for identifying the critical driving frequency.","title":"1.3 Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-parameter-dependence","text":"Damping coefficient ( \\(b\\) ): Controls energy dissipation Low \\(b\\) : resonance peak is sharp High \\(b\\) : oscillations decay quickly, response is flatter Driving amplitude ( \\(A\\) ): Larger \\(A\\) : stronger external influence Can drive the system into nonlinear or chaotic regimes Driving frequency ( \\(\\omega\\) ): If near \\(\\omega_0\\) : resonance Away from \\(\\omega_0\\) : weak or slow oscillations","title":"2.1 Parameter Dependence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-transition-to-chaos","text":"When the small-angle approximation is no longer valid, the equation becomes nonlinear. For certain values of \\(A\\) , \\(\\omega\\) , and \\(b\\) , the system exhibits: Period doubling Quasiperiodicity Chaotic motion (sensitive dependence on initial conditions) To analyze this, phase portraits and Poincar\u00e9 sections (sampling phase space at intervals of the driving period) are useful.","title":"2.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum is a model for many systems: Energy harvesting: Mechanical systems coupled to electromagnetic or piezoelectric generators Suspension bridges: Dynamic loads (e.g., wind) may cause resonance Clock mechanisms: Pendulum dynamics must be stabilized for accurate timekeeping Oscillating circuits: Driven RLC circuits act as electrical analogs Biomechanics: Human gait and balance involve pendulum-like dynamics under control","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum(t, y, b, A, omega): theta, omega_theta = y dydt = [omega_theta, -b * omega_theta - np.sin(theta) + A * np.cos(omega * t)] return dydt # Time span and evaluation points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # Initial conditions: small angle, zero initial velocity y0 = [0.2, 0] # Define different scenarios scenarios = { \"Pure Pendulum\": {\"b\": 0.0, \"A\": 0.0, \"omega\": 0.0}, \"Damped Pendulum\": {\"b\": 0.5, \"A\": 0.0, \"omega\": 0.0}, \"Driven Pendulum\": {\"b\": 0.0, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (1)\": {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0}, \"Damped Driven (2)\": {\"b\": 0.2, \"A\": 0.8, \"omega\": 1.5} } # Solve the ODEs results = {} for name, params in scenarios.items(): sol = solve_ivp(pendulum, t_span, y0, args=(params[\"b\"], params[\"A\"], params[\"omega\"]), t_eval=t_eval) results[name] = sol # Plot phase space plt.figure(figsize=(12, 8)) for name, sol in results.items(): plt.plot(sol.y[0], sol.y[1], label=name) plt.title(\"Phase Space of Pendulum Scenarios\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"4.1 Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-pendulum","text":"To investigate chaotic dynamics in the forced damped pendulum, we visualize the motion using: Phase Space: Plot of \\(\\theta\\) vs \\(\\frac{d\\theta}{dt}\\) Poincar\u00e9 Section: Discrete samples of the system at each driving period Let the driving period be: \\[ T = \\frac{2\\pi}{\\omega} \\] We sample the pendulum state \\((\\theta, \\dot{\\theta})\\) at times \\(t = nT\\) . # Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time span and time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) # 1. Simple Pendulum def simple_pendulum(t, y): theta, omega = y dydt = [omega, -np.sin(theta)] return dydt sol1 = solve_ivp(simple_pendulum, t_span, [0.2, 0], t_eval=t_eval) # 2. Damped Pendulum def damped_pendulum(t, y, gamma=0.1): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta)] return dydt sol2 = solve_ivp(damped_pendulum, t_span, [0.8, 0], t_eval=t_eval) # 3. Forced Pendulum def forced_pendulum(t, y, gamma=0.2, A=1.5, omega_drive=2/3): theta, omega = y dydt = [omega, -gamma * omega - np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol3 = solve_ivp(forced_pendulum, t_span, [0.2, 0], t_eval=t_eval) # Plotting fig, axs = plt.subplots(3, 2, figsize=(12, 12)) # Simple axs[0, 0].plot(sol1.t, sol1.y[0], 'r') axs[0, 0].set_title(\"1) Simple Pendulum\\nTime Series\") axs[0, 1].plot(sol1.y[0], sol1.y[1], 'r') axs[0, 1].set_title(\"Phase Portrait\") # Damped axs[1, 0].plot(sol2.t, sol2.y[0], 'b') axs[1, 0].set_title(\"2) Damped Pendulum\\nTime Series\") axs[1, 1].plot(sol2.y[0], sol2.y[1], 'b') axs[1, 1].set_title(\"Phase Portrait\") # Forced axs[2, 0].plot(sol3.t, sol3.y[0], 'c') axs[2, 0].set_title(\"3) Forced Pendulum\\nTime Series\") axs[2, 1].plot(sol3.y[0], sol3.y[1], 'c') axs[2, 1].set_title(\"Phase Portrait\") for ax in axs.flat: ax.set_xlabel('Time (s)' if 'Time Series' in ax.get_title() else '\u03b8 (rad)') ax.set_ylabel('\u03b8 (rad)' if 'Time Series' in ax.get_title() else '\u03c9 (rad/s)') ax.grid(True) plt.tight_layout() plt.show()","title":"4.2 Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#my-colab-canliy961","text":"Pendulum Scenarios Plots1&2&3 Pendulum Plots4&5","title":"My Colab (Canliy961)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler\u2019s Third Law: Orbital Period and Orbital Radius 1. Theoretical Derivation Kepler\u2019s Third Law (Simplified for Circular Orbits) For a body in a circular orbit around a much more massive body, the gravitational force provides the necessary centripetal force: Gravitational Force: \\(F_{\\text{gravity}} = \\frac{G M m}{r^2}\\) Centripetal Force: \\(F_{\\text{centripetal}} = \\frac{m v^2}{r}\\) Equating both forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is related to velocity \\(v\\) and radius \\(r\\) : \\[ v = \\frac{2\\pi r}{T} \\Rightarrow \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\Rightarrow \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) 2. Astronomical Implications Planetary Mass Determination: If you know a moon's orbit ( \\(T\\) , \\(r\\) ), you can calculate the mass of the planet using: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Interplanetary Distance: Comparing periods and distances of planets allows relative distances from the Sun to be calculated without direct measurements. Satellite Orbit Design: Used to determine the correct altitude for geosynchronous orbits. Newton\u2019s Form of Kepler\u2019s Third Law Newton's version of Kepler\u2019s Third Law is: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Where: - \\(T\\) is the orbital period (in seconds) - \\(r\\) is the orbital radius (in meters) - \\(G\\) is the gravitational constant, approximately \\(6.674 \\times 10^{-11} \\ \\text{m}^3 \\ \\text{kg}^{-1} \\ \\text{s}^{-2}\\) - \\(M\\) is the mass of the central object (Earth or Sun) 2.1 Mass of the Earth (using the Moon's orbit) Given: - \\(T = 27.3\\) days \\(= 2.36 \\times 10^6\\) s - \\(r = 3.84 \\times 10^8\\) m From the formula: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Substitute the values: \\[ M = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2} \\] Result: \\[ M \\approx 5.97 \\times 10^{24} \\ \\text{kg} \\] This is the mass of the Earth . 2.2 Mass of the Sun (using Earth's orbit) Given: - \\(T = 1\\) year \\(= 3.156 \\times 10^7\\) s - \\(r = 1.496 \\times 10^{11}\\) m Apply the same formula: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Substitute the values: \\[ M = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{6.674 \\times 10^{-11} (3.156 \\times 10^7)^2} \\] Result: \\[ M \\approx 1.99 \\times 10^{30} \\ \\text{kg} \\] This is the mass of the Sun . 3. Real-World Examples Example 1: The Moon Orbiting Earth Radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) Period: \\(T \\approx 27.3 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) Using Kepler\u2019s law, we can estimate Earth\u2019s mass. Example 2: Solar System Planets By plotting \\(\\log(T)\\) vs. \\(\\log(r)\\) for planets, we should get a straight line with slope \\(\\approx 1.5\\) . 4. Computational Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 1.989e30 # Mass of the Sun (kg) # Orbital radii (m) - approximate average values radii = np.array([ 5.79e10, # Mercury 1.08e11, # Venus 1.50e11, # Earth 2.28e11, # Mars 7.78e11, # Jupiter 1.43e12, # Saturn 2.87e12, # Uranus 4.50e12 # Neptune ]) # Compute periods using Kepler's Third Law T = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Plot log(T) vs log(r) plt.figure(figsize=(8,6)) plt.plot(np.log10(radii), np.log10(T), 'o-') plt.xlabel(\"log10(Orbital Radius) [log10(m)]\") plt.ylabel(\"log10(Orbital Period) [log10(s)]\") plt.title(\"Kepler\u2019s Third Law: log-log plot\") plt.grid(True) plt.show() 5. Graphical Representation A circular orbit simulation can be animated using matplotlib.animation . Orbital period data from real planets supports the \\(T^2 \\propto r^3\\) relationship. 6. Extension to Elliptical Orbits Kepler\u2019s Third Law still applies if \\(r\\) is replaced with the semi-major axis \\(a\\) . For elliptical orbits: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This allows for broader applications, including comets, exoplanets, and binary stars. My Colab (Canliy961) Kepler's Third Law","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"","title":"Kepler\u2019s Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Kepler\u2019s Third Law (Simplified for Circular Orbits) For a body in a circular orbit around a much more massive body, the gravitational force provides the necessary centripetal force: Gravitational Force: \\(F_{\\text{gravity}} = \\frac{G M m}{r^2}\\) Centripetal Force: \\(F_{\\text{centripetal}} = \\frac{m v^2}{r}\\) Equating both forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is related to velocity \\(v\\) and radius \\(r\\) : \\[ v = \\frac{2\\pi r}{T} \\Rightarrow \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\Rightarrow \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\)","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"Planetary Mass Determination: If you know a moon's orbit ( \\(T\\) , \\(r\\) ), you can calculate the mass of the planet using: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Interplanetary Distance: Comparing periods and distances of planets allows relative distances from the Sun to be calculated without direct measurements. Satellite Orbit Design: Used to determine the correct altitude for geosynchronous orbits.","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-form-of-keplers-third-law","text":"Newton's version of Kepler\u2019s Third Law is: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Where: - \\(T\\) is the orbital period (in seconds) - \\(r\\) is the orbital radius (in meters) - \\(G\\) is the gravitational constant, approximately \\(6.674 \\times 10^{-11} \\ \\text{m}^3 \\ \\text{kg}^{-1} \\ \\text{s}^{-2}\\) - \\(M\\) is the mass of the central object (Earth or Sun)","title":"Newton\u2019s Form of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-mass-of-the-earth-using-the-moons-orbit","text":"Given: - \\(T = 27.3\\) days \\(= 2.36 \\times 10^6\\) s - \\(r = 3.84 \\times 10^8\\) m From the formula: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Substitute the values: \\[ M = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2} \\] Result: \\[ M \\approx 5.97 \\times 10^{24} \\ \\text{kg} \\] This is the mass of the Earth .","title":"2.1 Mass of the Earth (using the Moon's orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#22-mass-of-the-sun-using-earths-orbit","text":"Given: - \\(T = 1\\) year \\(= 3.156 \\times 10^7\\) s - \\(r = 1.496 \\times 10^{11}\\) m Apply the same formula: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Substitute the values: \\[ M = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{6.674 \\times 10^{-11} (3.156 \\times 10^7)^2} \\] Result: \\[ M \\approx 1.99 \\times 10^{30} \\ \\text{kg} \\] This is the mass of the Sun .","title":"2.2 Mass of the Sun (using Earth's orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon-orbiting-earth","text":"Radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) Period: \\(T \\approx 27.3 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) Using Kepler\u2019s law, we can estimate Earth\u2019s mass.","title":"Example 1: The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-solar-system-planets","text":"By plotting \\(\\log(T)\\) vs. \\(\\log(r)\\) for planets, we should get a straight line with slope \\(\\approx 1.5\\) .","title":"Example 2: Solar System Planets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 1.989e30 # Mass of the Sun (kg) # Orbital radii (m) - approximate average values radii = np.array([ 5.79e10, # Mercury 1.08e11, # Venus 1.50e11, # Earth 2.28e11, # Mars 7.78e11, # Jupiter 1.43e12, # Saturn 2.87e12, # Uranus 4.50e12 # Neptune ]) # Compute periods using Kepler's Third Law T = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Plot log(T) vs log(r) plt.figure(figsize=(8,6)) plt.plot(np.log10(radii), np.log10(T), 'o-') plt.xlabel(\"log10(Orbital Radius) [log10(m)]\") plt.ylabel(\"log10(Orbital Period) [log10(s)]\") plt.title(\"Kepler\u2019s Third Law: log-log plot\") plt.grid(True) plt.show()","title":"4. Computational Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-graphical-representation","text":"A circular orbit simulation can be animated using matplotlib.animation . Orbital period data from real planets supports the \\(T^2 \\propto r^3\\) relationship.","title":"5. Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law still applies if \\(r\\) is replaced with the semi-major axis \\(a\\) . For elliptical orbits: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This allows for broader applications, including comets, exoplanets, and binary stars.","title":"6. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#my-colab-canliy961","text":"Kepler's Third Law","title":"My Colab (Canliy961)"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Definitions Cosmic Velocities: Derivation, Earth Values and Comparison A. Derivation of the Three Cosmic Velocities A.1 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed needed for an object to stay in a stable circular orbit just above the surface of a planet. The gravitational force between the planet and the object provides the necessary centripetal force for the orbit: Gravitational force: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Centripetal force: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting them equal: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) and rearrange: \\[ v^2 = \\frac{G M}{r} \\] Taking the square root: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Thus, the first cosmic velocity is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] A.2 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum speed required to completely escape a planet\u2019s gravitational pull. Using energy conservation: Kinetic energy: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\] Gravitational potential energy: \\[ E_{\\text{potential}} = -\\frac{G M m}{r} \\] At escape, total energy = 0: \\[ \\frac{1}{2} m v^2 - \\frac{G M m}{r} = 0 \\] Simplifying: \\[ \\frac{1}{2} v^2 = \\frac{G M}{r} \\] Multiply by 2: \\[ v^2 = \\frac{2 G M}{r} \\] Taking the square root: \\[ v = \\sqrt{\\frac{2 G M}{r}} \\] Thus, the second cosmic velocity is: \\[ v_2 = \\sqrt{2} \\times v_1 \\] A.3 Third Cosmic Velocity (Solar System Escape Velocity) The third cosmic velocity is the speed needed to escape not just the planet but also the gravitational pull of the Sun, starting from the Earth's orbit. The escape velocity from the Sun at Earth\u2019s orbit is: \\[ v_{\\text{sun-escape}} = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{orbit}}}} \\] However, because the Earth itself is moving at about 30 km/s around the Sun, the spacecraft already has that speed. Thus, the additional speed needed is calculated based on energy addition, and the final result for escape from Earth's surface is approximately: \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\] B. Values of Three Cosmic Velocities for Earth Using Earth\u2019s data: Gravitational constant: \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Earth mass: \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) Earth radius: \\(r = 6.371 \\times 10^6 \\, \\text{m}\\) Calculations: First Cosmic Velocity: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\approx 7.91 \\, \\text{km/s} \\] Second Cosmic Velocity: \\[ v_2 = \\sqrt{2} \\times v_1 \\approx 11.18 \\, \\text{km/s} \\] Third Cosmic Velocity: \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\] C. Comparison: Earth, Moon, Mars, and Jupiter C.1 Physical Data Celestial Body Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Moon \\(7.347 \\times 10^{22}\\) \\(1.737 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.3895 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) C.2 Calculated Velocities Celestial Body First Cosmic Velocity (km/s) Second Cosmic Velocity (km/s) Earth 7.91 11.18 Moon 1.68 2.38 Mars 3.55 5.02 Jupiter 42.08 59.49 2. Mathematical Derivations 2.1 Derivation of the First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed required for an object to maintain a stable circular orbit around a planet without falling back. To find it, we equate: The gravitational force pulling the object toward the planet The centripetal force needed to keep the object moving in a circle. Gravitational force: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Centripetal force: \\[ F_{\\text{centripetal}} = \\frac{m v_1^2}{r} \\] Setting them equal: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\] We can cancel \\(m\\) from both sides: \\[ \\frac{G M}{r^2} = \\frac{v_1^2}{r} \\] Multiplying both sides by \\(r\\) : \\[ \\frac{G M}{r} = v_1^2 \\] Taking the square root: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Thus, the first cosmic velocity formula is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] 2.2 Derivation of the Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum speed needed to completely escape the gravitational field of a planet without further propulsion. To derive it, we use energy conservation: The object's initial kinetic energy must be enough to counterbalance the gravitational potential energy. Initial kinetic energy: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v_2^2 \\] Gravitational potential energy: \\[ E_{\\text{potential}} = -\\frac{G M m}{r} \\] At the point of escape, total energy = 0: \\[ E_{\\text{kinetic}} + E_{\\text{potential}} = 0 \\] Substituting: \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 \\] Rearranging: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{r} \\] Cancel \\(m\\) from both sides: \\[ \\frac{1}{2} v_2^2 = \\frac{G M}{r} \\] Multiplying both sides by 2: \\[ v_2^2 = \\frac{2 G M}{r} \\] Taking the square root: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Thus, the second cosmic velocity is: \\[ v_2 = \\sqrt{2} \\times v_1 \\] 2.3 Derivation of the Third Cosmic Velocity (Solar System Escape Velocity) The third cosmic velocity is the minimum speed needed for an object to escape not only Earth's gravity, but also the Sun's gravitational pull, starting from Earth's orbit. First, the escape velocity from the Sun at Earth's distance is: \\[ v_{\\text{sun-escape}} = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{orbit}}}} \\] Where: \\(M_{\\text{sun}}\\) is the Sun's mass, \\(r_{\\text{orbit}}\\) is Earth's distance from the Sun (about \\(1.496 \\times 10^{11} \\, \\text{m}\\) ). However, because the Earth is already moving around the Sun with an orbital speed of about 30 km/s, a spacecraft launched from Earth already has this speed. Thus, the spacecraft needs enough additional velocity to make the total energy zero relative to the Sun. The final approximate third cosmic velocity from Earth's surface, considering Earth's gravity and solar effects, is about: \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\] Quick Summary Velocity Type Derived Formula Meaning First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Stay in circular orbit Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2 G M}{r}}\\) or \\(v_2 = \\sqrt{2} \\times v_1\\) Escape planet's gravity Third Cosmic Velocity \\(v_3 \\approx 16.7 \\, \\text{km/s}\\) Escape Sun's gravity from Earth's orbit 3. Python Simulation and Visualization # cosmic_velocities.py import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M_earth = 5.972e24 # mass of Earth, kg R_earth = 6.371e6 # radius of Earth, m # Functions for velocities def v1(M, r): return np.sqrt(G * M / r) / 1000 # in km/s def v2(M, r): return np.sqrt(2 * G * M / r) / 1000 # in km/s # Third cosmic velocity approximation (given) v3_earth = 16.7 # km/s # Generate data radii = np.linspace(R_earth, 10 * R_earth, 500) # From Earth's radius up to 10 times v1_values = v1(M_earth, radii) v2_values = v2(M_earth, radii) # Plotting plt.figure(figsize=(10, 6)) plt.plot(radii / 1e6, v1_values, label='First Cosmic Velocity (Orbital)', linestyle='-') plt.plot(radii / 1e6, v2_values, label='Second Cosmic Velocity (Escape)', linestyle='--') plt.axhline(y=v3_earth, color='r', linestyle=':', label='Third Cosmic Velocity (Solar Escape)') plt.xlabel('Distance from Center of Earth (Million meters)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities as a Function of Distance') plt.legend() plt.grid(True) plt.show() My Colab (Canliy961) Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions","text":"","title":"1. Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-derivation-earth-values-and-comparison","text":"","title":"Cosmic Velocities: Derivation, Earth Values and Comparison"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a-derivation-of-the-three-cosmic-velocities","text":"","title":"A. Derivation of the Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum speed needed for an object to stay in a stable circular orbit just above the surface of a planet. The gravitational force between the planet and the object provides the necessary centripetal force for the orbit: Gravitational force: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Centripetal force: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting them equal: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) and rearrange: \\[ v^2 = \\frac{G M}{r} \\] Taking the square root: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Thus, the first cosmic velocity is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"A.1 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum speed required to completely escape a planet\u2019s gravitational pull. Using energy conservation: Kinetic energy: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\] Gravitational potential energy: \\[ E_{\\text{potential}} = -\\frac{G M m}{r} \\] At escape, total energy = 0: \\[ \\frac{1}{2} m v^2 - \\frac{G M m}{r} = 0 \\] Simplifying: \\[ \\frac{1}{2} v^2 = \\frac{G M}{r} \\] Multiply by 2: \\[ v^2 = \\frac{2 G M}{r} \\] Taking the square root: \\[ v = \\sqrt{\\frac{2 G M}{r}} \\] Thus, the second cosmic velocity is: \\[ v_2 = \\sqrt{2} \\times v_1 \\]","title":"A.2 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a3-third-cosmic-velocity-solar-system-escape-velocity","text":"The third cosmic velocity is the speed needed to escape not just the planet but also the gravitational pull of the Sun, starting from the Earth's orbit. The escape velocity from the Sun at Earth\u2019s orbit is: \\[ v_{\\text{sun-escape}} = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{orbit}}}} \\] However, because the Earth itself is moving at about 30 km/s around the Sun, the spacecraft already has that speed. Thus, the additional speed needed is calculated based on energy addition, and the final result for escape from Earth's surface is approximately: \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\]","title":"A.3 Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#b-values-of-three-cosmic-velocities-for-earth","text":"Using Earth\u2019s data: Gravitational constant: \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Earth mass: \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) Earth radius: \\(r = 6.371 \\times 10^6 \\, \\text{m}\\)","title":"B. Values of Three Cosmic Velocities for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations","text":"First Cosmic Velocity: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\approx 7.91 \\, \\text{km/s} \\] Second Cosmic Velocity: \\[ v_2 = \\sqrt{2} \\times v_1 \\approx 11.18 \\, \\text{km/s} \\] Third Cosmic Velocity: \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\]","title":"Calculations:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c-comparison-earth-moon-mars-and-jupiter","text":"","title":"C. Comparison: Earth, Moon, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c1-physical-data","text":"Celestial Body Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Moon \\(7.347 \\times 10^{22}\\) \\(1.737 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.3895 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\)","title":"C.1 Physical Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c2-calculated-velocities","text":"Celestial Body First Cosmic Velocity (km/s) Second Cosmic Velocity (km/s) Earth 7.91 11.18 Moon 1.68 2.38 Mars 3.55 5.02 Jupiter 42.08 59.49","title":"C.2 Calculated Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-derivation-of-the-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum speed required for an object to maintain a stable circular orbit around a planet without falling back. To find it, we equate: The gravitational force pulling the object toward the planet The centripetal force needed to keep the object moving in a circle. Gravitational force: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Centripetal force: \\[ F_{\\text{centripetal}} = \\frac{m v_1^2}{r} \\] Setting them equal: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\] We can cancel \\(m\\) from both sides: \\[ \\frac{G M}{r^2} = \\frac{v_1^2}{r} \\] Multiplying both sides by \\(r\\) : \\[ \\frac{G M}{r} = v_1^2 \\] Taking the square root: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Thus, the first cosmic velocity formula is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"2.1 Derivation of the First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-derivation-of-the-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum speed needed to completely escape the gravitational field of a planet without further propulsion. To derive it, we use energy conservation: The object's initial kinetic energy must be enough to counterbalance the gravitational potential energy. Initial kinetic energy: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v_2^2 \\] Gravitational potential energy: \\[ E_{\\text{potential}} = -\\frac{G M m}{r} \\] At the point of escape, total energy = 0: \\[ E_{\\text{kinetic}} + E_{\\text{potential}} = 0 \\] Substituting: \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 \\] Rearranging: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{r} \\] Cancel \\(m\\) from both sides: \\[ \\frac{1}{2} v_2^2 = \\frac{G M}{r} \\] Multiplying both sides by 2: \\[ v_2^2 = \\frac{2 G M}{r} \\] Taking the square root: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Thus, the second cosmic velocity is: \\[ v_2 = \\sqrt{2} \\times v_1 \\]","title":"2.2 Derivation of the Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-derivation-of-the-third-cosmic-velocity-solar-system-escape-velocity","text":"The third cosmic velocity is the minimum speed needed for an object to escape not only Earth's gravity, but also the Sun's gravitational pull, starting from Earth's orbit. First, the escape velocity from the Sun at Earth's distance is: \\[ v_{\\text{sun-escape}} = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{orbit}}}} \\] Where: \\(M_{\\text{sun}}\\) is the Sun's mass, \\(r_{\\text{orbit}}\\) is Earth's distance from the Sun (about \\(1.496 \\times 10^{11} \\, \\text{m}\\) ). However, because the Earth is already moving around the Sun with an orbital speed of about 30 km/s, a spacecraft launched from Earth already has this speed. Thus, the spacecraft needs enough additional velocity to make the total energy zero relative to the Sun. The final approximate third cosmic velocity from Earth's surface, considering Earth's gravity and solar effects, is about: \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\]","title":"2.3 Derivation of the Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#quick-summary","text":"Velocity Type Derived Formula Meaning First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Stay in circular orbit Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2 G M}{r}}\\) or \\(v_2 = \\sqrt{2} \\times v_1\\) Escape planet's gravity Third Cosmic Velocity \\(v_3 \\approx 16.7 \\, \\text{km/s}\\) Escape Sun's gravity from Earth's orbit","title":"Quick Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-simulation-and-visualization","text":"# cosmic_velocities.py import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M_earth = 5.972e24 # mass of Earth, kg R_earth = 6.371e6 # radius of Earth, m # Functions for velocities def v1(M, r): return np.sqrt(G * M / r) / 1000 # in km/s def v2(M, r): return np.sqrt(2 * G * M / r) / 1000 # in km/s # Third cosmic velocity approximation (given) v3_earth = 16.7 # km/s # Generate data radii = np.linspace(R_earth, 10 * R_earth, 500) # From Earth's radius up to 10 times v1_values = v1(M_earth, radii) v2_values = v2(M_earth, radii) # Plotting plt.figure(figsize=(10, 6)) plt.plot(radii / 1e6, v1_values, label='First Cosmic Velocity (Orbital)', linestyle='-') plt.plot(radii / 1e6, v2_values, label='Second Cosmic Velocity (Escape)', linestyle='--') plt.axhline(y=v3_earth, color='r', linestyle=':', label='Third Cosmic Velocity (Solar Escape)') plt.xlabel('Distance from Center of Earth (Million meters)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities as a Function of Distance') plt.legend() plt.grid(True) plt.show()","title":"3. Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#my-colab-canliy961","text":"Cosmic Velocities","title":"My Colab (Canliy961)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Theoretical Background When a payload is released from a moving spacecraft near Earth, its trajectory depends on: Initial position (altitude above Earth's surface), Initial velocity (magnitude and direction), Gravitational force acting toward Earth\u2019s center. The motion is governed by Newton\u2019s Law of Universal Gravitation: \\[ F = \\frac{G M m}{r^2} \\] Where: \\(F\\) is the gravitational force, \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) is the gravitational constant, \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), \\(m\\) is the mass of the payload (cancels out), \\(r\\) is the distance from Earth's center. The equation of motion becomes: \\[ \\ddot{r} = -\\frac{G M}{r^3} r \\] Depending on the energy: Elliptical trajectory if total energy \\(E < 0\\) , Parabolic trajectory if \\(E = 0\\) , Hyperbolic trajectory if \\(E > 0\\) . Where total energy: \\[ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} \\] Escape velocity at a given altitude: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}} \\] If \\(v < v_{\\text{esc}}\\) : payload remains bound (orbit or reentry). If \\(v \\geq v_{\\text{esc}}\\) : payload escapes Earth\u2019s gravity. 2. Numerical Simulation Approach We solve the second-order differential equation for motion numerically using time stepping (Euler or Runge-Kutta 4th order). At each time step: Update acceleration based on current position. Update velocity based on acceleration. Update position based on velocity. We assume: No atmospheric drag (valid at high altitudes). 3. Python Script import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M_earth = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters # Function to compute acceleration def acceleration(r): r_norm = np.linalg.norm(r) return -G * M_earth * r / r_norm**3 # Runge-Kutta 4th order method def rk4_step(r, v, dt): k1_v = acceleration(r) k1_r = v k2_v = acceleration(r + 0.5*dt*k1_r) k2_r = v + 0.5*dt*k1_v k3_v = acceleration(r + 0.5*dt*k2_r) k3_r = v + 0.5*dt*k2_v k4_v = acceleration(r + dt*k3_r) k4_r = v + dt*k3_v r_new = r + (dt/6)*(k1_r + 2*k2_r + 2*k3_r + k4_r) v_new = v + (dt/6)*(k1_v + 2*k2_v + 2*k3_v + k4_v) return r_new, v_new # Simulation function def simulate_trajectory(r0, v0, t_max, dt): r = r0.copy() v = v0.copy() positions = [r0] for _ in range(int(t_max/dt)): r, v = rk4_step(r, v, dt) positions.append(r) if np.linalg.norm(r) < R_earth: # collision with Earth break return np.array(positions) # Initial conditions altitude = 800e3 # 800 km above Earth's surface r0 = np.array([R_earth + altitude, 0]) # starting position on the right v_magnitudes = np.arange(5e3, 13.5e3, 0.5e3) # from 5 km/s to 13 km/s # Plot setup fig, ax = plt.subplots(figsize=(12,12)) # Draw Earth (darker blue) theta = np.linspace(0, 2*np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, color='royalblue', label=\"Earth\") # Mark center of Earth ax.plot(0, 0, 'r.', markersize=10, label=\"Center of Earth\") # Simulate and plot for each velocity for idx, v0_mag in enumerate(v_magnitudes): v0 = np.array([0, v0_mag]) # vertically shooting trajectory = simulate_trajectory(r0, v0, t_max=15000, dt=1) ax.plot(trajectory[:,0], trajectory[:,1], lw=2, label=f'{v0_mag/1e3:.1f} km/s') # Final plot settings ax.set_xlabel('x (m)', fontsize=14) ax.set_ylabel('y (m)', fontsize=14) ax.set_title('Trajectories in a Gravitational Field with Filled Earth', fontsize=16) ax.legend(fontsize=10) ax.grid(True) ax.axis('equal') ax.set_xlim(-4e7, 4e7) ax.set_ylim(-4e7, 4e7) plt.show() My Colab (Canliy961) Trajectories in Gravitational Field","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-background","text":"When a payload is released from a moving spacecraft near Earth, its trajectory depends on: Initial position (altitude above Earth's surface), Initial velocity (magnitude and direction), Gravitational force acting toward Earth\u2019s center. The motion is governed by Newton\u2019s Law of Universal Gravitation: \\[ F = \\frac{G M m}{r^2} \\] Where: \\(F\\) is the gravitational force, \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) is the gravitational constant, \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), \\(m\\) is the mass of the payload (cancels out), \\(r\\) is the distance from Earth's center. The equation of motion becomes: \\[ \\ddot{r} = -\\frac{G M}{r^3} r \\] Depending on the energy: Elliptical trajectory if total energy \\(E < 0\\) , Parabolic trajectory if \\(E = 0\\) , Hyperbolic trajectory if \\(E > 0\\) . Where total energy: \\[ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} \\] Escape velocity at a given altitude: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}} \\] If \\(v < v_{\\text{esc}}\\) : payload remains bound (orbit or reentry). If \\(v \\geq v_{\\text{esc}}\\) : payload escapes Earth\u2019s gravity.","title":"1. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-simulation-approach","text":"We solve the second-order differential equation for motion numerically using time stepping (Euler or Runge-Kutta 4th order). At each time step: Update acceleration based on current position. Update velocity based on acceleration. Update position based on velocity. We assume: No atmospheric drag (valid at high altitudes).","title":"2. Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-script","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M_earth = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters # Function to compute acceleration def acceleration(r): r_norm = np.linalg.norm(r) return -G * M_earth * r / r_norm**3 # Runge-Kutta 4th order method def rk4_step(r, v, dt): k1_v = acceleration(r) k1_r = v k2_v = acceleration(r + 0.5*dt*k1_r) k2_r = v + 0.5*dt*k1_v k3_v = acceleration(r + 0.5*dt*k2_r) k3_r = v + 0.5*dt*k2_v k4_v = acceleration(r + dt*k3_r) k4_r = v + dt*k3_v r_new = r + (dt/6)*(k1_r + 2*k2_r + 2*k3_r + k4_r) v_new = v + (dt/6)*(k1_v + 2*k2_v + 2*k3_v + k4_v) return r_new, v_new # Simulation function def simulate_trajectory(r0, v0, t_max, dt): r = r0.copy() v = v0.copy() positions = [r0] for _ in range(int(t_max/dt)): r, v = rk4_step(r, v, dt) positions.append(r) if np.linalg.norm(r) < R_earth: # collision with Earth break return np.array(positions) # Initial conditions altitude = 800e3 # 800 km above Earth's surface r0 = np.array([R_earth + altitude, 0]) # starting position on the right v_magnitudes = np.arange(5e3, 13.5e3, 0.5e3) # from 5 km/s to 13 km/s # Plot setup fig, ax = plt.subplots(figsize=(12,12)) # Draw Earth (darker blue) theta = np.linspace(0, 2*np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, color='royalblue', label=\"Earth\") # Mark center of Earth ax.plot(0, 0, 'r.', markersize=10, label=\"Center of Earth\") # Simulate and plot for each velocity for idx, v0_mag in enumerate(v_magnitudes): v0 = np.array([0, v0_mag]) # vertically shooting trajectory = simulate_trajectory(r0, v0, t_max=15000, dt=1) ax.plot(trajectory[:,0], trajectory[:,1], lw=2, label=f'{v0_mag/1e3:.1f} km/s') # Final plot settings ax.set_xlabel('x (m)', fontsize=14) ax.set_ylabel('y (m)', fontsize=14) ax.set_title('Trajectories in a Gravitational Field with Filled Earth', fontsize=16) ax.legend(fontsize=10) ax.grid(True) ax.axis('equal') ax.set_xlim(-4e7, 4e7) ax.set_ylim(-4e7, 4e7) plt.show()","title":"3. Python Script"},{"location":"1%20Physics/2%20Gravity/Problem_3/#my-colab-canliy961","text":"Trajectories in Gravitational Field","title":"My Colab (Canliy961)"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Introduction We study the interference of waves generated from multiple point sources arranged at the vertices of a regular polygon. Each source emits circular waves, and the principle of superposition is used to find the overall displacement on the surface. 2. Polygon Selection We choose a square (regular quadrilateral) for simplicity. Thus, 4 sources are placed at the vertices of a square. 3. Mathematical Model A single wave from a source at \\((x_0, y_0)\\) is: \\[ \\eta(x,y,t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] where: \\[ r = \\sqrt{(x-x_0)^2 + (y-y_0)^2} \\] \\[ k = \\frac{2\\pi}{\\lambda} \\quad \\text{(wave number)} \\] \\[ \\omega = 2\\pi f \\quad \\text{(angular frequency)} \\] \\(A\\) is the amplitude, and \\(\\phi\\) is the initial phase (we can set \\(\\phi = 0\\) for simplicity). The total displacement is: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{4} \\eta_i(x,y,t) \\] 4. Simulation Setup All sources have the same \\(A\\) , \\(\\lambda\\) , and \\(f\\) . The square is centered at the origin, with vertices at: \\((d, d)\\) \\((-d, d)\\) \\((-d, -d)\\) \\((d, -d)\\) We will simulate the water surface over a grid in \\((x,y)\\) space. 5. Python Code # Import necessary libraries import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude wavelength = 5.0 # Wavelength (lambda) frequency = 1.0 # Frequency (Hz) k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency phi = 0 # Phase d = 5.0 # Half-length of square side (distance from center to vertex) # Time at which to evaluate t = 0.0 # Grid setup x = np.linspace(-15, 15, 500) y = np.linspace(-15, 15, 500) X, Y = np.meshgrid(x, y) # Source positions (square vertices) sources = [ (d, d), (-d, d), (-d, -d), (d, -d) ] # Calculate total displacement eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Add small term to avoid division by zero eta = (A / r) * np.cos(k * r - omega * t + phi) eta_sum += eta # Plotting plt.figure(figsize=(10, 8)) plt.pcolormesh(X, Y, eta_sum, shading='auto', cmap='viridis') plt.colorbar(label='Displacement $\\eta(x,y,t)$') plt.title('Interference Pattern from Four Sources at Square Vertices') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.scatter(*zip(*sources), color='red', marker='x', label='Sources') plt.legend() plt.axis('equal') plt.show() 6. Analysis of Interference Patterns Constructive Interference: Occurs where the waves from all sources arrive in phase (crest meets crest). These appear as bright regions on the plot. Destructive Interference: Occurs where waves are out of phase (crest meets trough), leading to cancellation. These appear as dark regions. Pattern Symmetry: Since the sources are symmetrically placed (square), the interference pattern is symmetric about the \\(x\\) and \\(y\\) axes. Radial Effects: Close to each source, circular patterns dominate. Farther away, the patterns become more complex due to interaction of multiple wavefronts. 7. Possible Extensions Animate the pattern over time to visualize how the interference evolves dynamically. Try other polygons (triangle, pentagon, hexagon) and compare the resulting patterns. Introduce slight phase differences between the sources and study how the interference pattern changes. My Colab (Canliy961) Wave Interference","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-introduction","text":"We study the interference of waves generated from multiple point sources arranged at the vertices of a regular polygon. Each source emits circular waves, and the principle of superposition is used to find the overall displacement on the surface.","title":"1. Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-polygon-selection","text":"We choose a square (regular quadrilateral) for simplicity. Thus, 4 sources are placed at the vertices of a square.","title":"2. Polygon Selection"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-mathematical-model","text":"A single wave from a source at \\((x_0, y_0)\\) is: \\[ \\eta(x,y,t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] where: \\[ r = \\sqrt{(x-x_0)^2 + (y-y_0)^2} \\] \\[ k = \\frac{2\\pi}{\\lambda} \\quad \\text{(wave number)} \\] \\[ \\omega = 2\\pi f \\quad \\text{(angular frequency)} \\] \\(A\\) is the amplitude, and \\(\\phi\\) is the initial phase (we can set \\(\\phi = 0\\) for simplicity). The total displacement is: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{4} \\eta_i(x,y,t) \\]","title":"3. Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-simulation-setup","text":"All sources have the same \\(A\\) , \\(\\lambda\\) , and \\(f\\) . The square is centered at the origin, with vertices at: \\((d, d)\\) \\((-d, d)\\) \\((-d, -d)\\) \\((d, -d)\\) We will simulate the water surface over a grid in \\((x,y)\\) space.","title":"4. Simulation Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-python-code","text":"# Import necessary libraries import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude wavelength = 5.0 # Wavelength (lambda) frequency = 1.0 # Frequency (Hz) k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency phi = 0 # Phase d = 5.0 # Half-length of square side (distance from center to vertex) # Time at which to evaluate t = 0.0 # Grid setup x = np.linspace(-15, 15, 500) y = np.linspace(-15, 15, 500) X, Y = np.meshgrid(x, y) # Source positions (square vertices) sources = [ (d, d), (-d, d), (-d, -d), (d, -d) ] # Calculate total displacement eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Add small term to avoid division by zero eta = (A / r) * np.cos(k * r - omega * t + phi) eta_sum += eta # Plotting plt.figure(figsize=(10, 8)) plt.pcolormesh(X, Y, eta_sum, shading='auto', cmap='viridis') plt.colorbar(label='Displacement $\\eta(x,y,t)$') plt.title('Interference Pattern from Four Sources at Square Vertices') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.scatter(*zip(*sources), color='red', marker='x', label='Sources') plt.legend() plt.axis('equal') plt.show()","title":"5. Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-analysis-of-interference-patterns","text":"Constructive Interference: Occurs where the waves from all sources arrive in phase (crest meets crest). These appear as bright regions on the plot. Destructive Interference: Occurs where waves are out of phase (crest meets trough), leading to cancellation. These appear as dark regions. Pattern Symmetry: Since the sources are symmetrically placed (square), the interference pattern is symmetric about the \\(x\\) and \\(y\\) axes. Radial Effects: Close to each source, circular patterns dominate. Farther away, the patterns become more complex due to interaction of multiple wavefronts.","title":"6. Analysis of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-possible-extensions","text":"Animate the pattern over time to visualize how the interference evolves dynamically. Try other polygons (triangle, pentagon, hexagon) and compare the resulting patterns. Introduce slight phase differences between the sources and study how the interference pattern changes.","title":"7. Possible Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#my-colab-canliy961","text":"Wave Interference","title":"My Colab (Canliy961)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force 1. Exploration of Applications The Lorentz force governs the dynamics of charged particles in electric and magnetic fields: \\(F = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\) Key Applications: - Particle accelerators (e.g., cyclotrons, synchrotrons): guide particles in circular paths using magnetic fields. - Mass spectrometers : use electric and magnetic fields to separate particles by mass-to-charge ratio. - Plasma confinement : magnetic fields trap and control plasma in fusion devices like tokamaks. - Astrophysics : cosmic rays spiral along interstellar magnetic field lines. 2. Simulating Particle Motion Governing Equation: We simulate particle motion using Newton\u2019s 2nd law: \\(m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\) Use Runge-Kutta (RK4) to solve this system numerically. 3. Python Code: Lorentz Force Simulation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] \u2014 increased to prevent blow-up dt = 0.001 # smaller time step for better stability steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] # First half-step velocity update (leapfrog) a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): # Full step position update r_next = r[-1] + v_half * dt r.append(r_next) # Compute acceleration at new position (based on velocity) a = lorentz_force(v_half, E, B) / m # Full step velocity update v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) # Store full-step velocity for record return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_spiral = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_spiral, E, B, r0) # 3D Plot of the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() 4. Parameter Exploration Field strengths ( \\(\\vec{E}\\) , \\(\\vec{B}\\) ): Increasing magnetic field strength increases curvature (reduces Larmor radius). Initial velocity ( \\(\\vec{v}_0\\) ): Faster particles form larger spirals. Charge-to-mass ratio ( \\(\\frac{q}{m}\\) ): Heavier particles spiral less tightly. Characteristic Quantities Larmor Radius: \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] Cyclotron Frequency: \\[ \\omega_c = \\frac{|q| B}{m} \\] These quantities determine circular and spiral motion of particles in magnetic fields. 5. Physical Interpretation Case 1: Uniform Magnetic Field Particle undergoes circular or helical motion. If velocity has a component along the field direction, motion is helical . Case 2: Crossed Electric and Magnetic Fields Particle experiences \\(\\vec{E} \\times \\vec{B}\\) drift : \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Explanation: The \\(\\vec{E} \\times \\vec{B}\\) drift velocity is given by: \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] For \\(\\vec{E} = [0, 10, 0]\\) and \\(\\vec{B} = [0, 0, 1]\\) , we get: \\[ \\vec{v}_{\\text{drift}} = \\frac{[0, 10, 0] \\times [0, 0, 1]}{1^2} = \\frac{[10, 0, 0]}{1} = [10, 0, 0] \\] The result is a circular or spiral motion in the plane, drifting steadily in the \\(x\\) -direction \u2014 a common effect in plasma physics and beam devices. My Colab (Canliy961) Lorentz Force","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force governs the dynamics of charged particles in electric and magnetic fields: \\(F = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\) Key Applications: - Particle accelerators (e.g., cyclotrons, synchrotrons): guide particles in circular paths using magnetic fields. - Mass spectrometers : use electric and magnetic fields to separate particles by mass-to-charge ratio. - Plasma confinement : magnetic fields trap and control plasma in fusion devices like tokamaks. - Astrophysics : cosmic rays spiral along interstellar magnetic field lines.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Governing Equation: We simulate particle motion using Newton\u2019s 2nd law: \\(m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\) Use Runge-Kutta (RK4) to solve this system numerically.","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-python-code-lorentz-force-simulation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] \u2014 increased to prevent blow-up dt = 0.001 # smaller time step for better stability steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] # First half-step velocity update (leapfrog) a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): # Full step position update r_next = r[-1] + v_half * dt r.append(r_next) # Compute acceleration at new position (based on velocity) a = lorentz_force(v_half, E, B) / m # Full step velocity update v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) # Store full-step velocity for record return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_spiral = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_spiral, E, B, r0) # 3D Plot of the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"3. Python Code: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"Field strengths ( \\(\\vec{E}\\) , \\(\\vec{B}\\) ): Increasing magnetic field strength increases curvature (reduces Larmor radius). Initial velocity ( \\(\\vec{v}_0\\) ): Faster particles form larger spirals. Charge-to-mass ratio ( \\(\\frac{q}{m}\\) ): Heavier particles spiral less tightly.","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#characteristic-quantities","text":"Larmor Radius: \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] Cyclotron Frequency: \\[ \\omega_c = \\frac{|q| B}{m} \\] These quantities determine circular and spiral motion of particles in magnetic fields.","title":"Characteristic Quantities"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-physical-interpretation","text":"","title":"5. Physical Interpretation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-1-uniform-magnetic-field","text":"Particle undergoes circular or helical motion. If velocity has a component along the field direction, motion is helical .","title":"Case 1: Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-2-crossed-electric-and-magnetic-fields","text":"Particle experiences \\(\\vec{E} \\times \\vec{B}\\) drift : \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Explanation: The \\(\\vec{E} \\times \\vec{B}\\) drift velocity is given by: \\[ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] For \\(\\vec{E} = [0, 10, 0]\\) and \\(\\vec{B} = [0, 0, 1]\\) , we get: \\[ \\vec{v}_{\\text{drift}} = \\frac{[0, 10, 0] \\times [0, 0, 1]}{1^2} = \\frac{[10, 0, 0]}{1} = [10, 0, 0] \\] The result is a circular or spiral motion in the plane, drifting steadily in the \\(x\\) -direction \u2014 a common effect in plasma physics and beam devices.","title":"Case 2: Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#my-colab-canliy961","text":"Lorentz Force","title":"My Colab (Canliy961)"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Central Limit Theorem (CLT) \u2013 Simulation and Analysis 1. Population Distributions Used We will use three types of distributions to represent different population shapes: Uniform Distribution : All values are equally likely. (Symmetric) Exponential Distribution : Highly right-skewed. (Asymmetric) Binomial Distribution : Discrete distribution counting the number of successes in fixed trials. Each population will consist of a large number of data points (e.g., 100,000 values) to closely approximate a real-world dataset. 2. Sampling and Sample Means From each population, we will: Randomly draw many samples of fixed sizes (e.g., 5, 10, 30, 50). Compute the sample mean for each sample. What Is a Sample Mean? The sample mean (average) of a sample of size \\(n\\) is given by: \\[ \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] \\] We will repeat the sampling process many times (e.g., 1,000 times per sample size) to build a sampling distribution of the sample mean. 3. Visualization of Sampling Distributions We will plot histograms of sample means for each sample size. As the sample size increases: The shape of the sampling distribution becomes more bell-shaped. The distribution gets more concentrated around the true population mean. This visually demonstrates how the CLT works in practice. 4. Effect of Sample Size on Spread According to the CLT, the variance of the sample mean decreases as the sample size increases: \\[ \\[ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} \\] \\] This means that: Larger samples lead to more consistent and reliable sample means. The spread (standard deviation) of the sampling distribution gets smaller as \\(n\\) increases. We will plot how the variance of the sample means changes with different sample sizes for each distribution. 5. Reflections and Real-World Applications Why is the Central Limit Theorem so important? Parameter Estimation: It justifies using sample means to estimate unknown population means. Confidence intervals are based on the assumption of normality of sample means. Quality Control: In manufacturing, means of product measurements are monitored using control charts, assuming normality. Finance and Economics: Financial returns of diversified portfolios often behave like normal distributions due to the CLT. Hypothesis Testing: Most parametric tests rely on the assumption that the sampling distribution of the test statistic is normal. 6. Python Simulation import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set seed for reproducibility np.random.seed(42) # ----- Population Generation ----- population_size = 100_000 pop_uniform = np.random.uniform(0, 1, population_size) pop_exponential = np.random.exponential(scale=1.0, size=population_size) pop_binomial = np.random.binomial(n=10, p=0.5, size=population_size) # ----- Plot Population Distribution ----- def plot_population(data, title): plt.figure(figsize=(6, 3)) sns.histplot(data, bins=50, kde=True) plt.title(f'{title} Population') plt.xlabel('Value') plt.ylabel('Frequency') plt.grid(True) plt.show() plot_population(pop_uniform, \"Uniform\") plot_population(pop_exponential, \"Exponential\") plot_population(pop_binomial, \"Binomial\") # ----- Simulate Sampling Distribution ----- def simulate_sampling_distribution(population, sample_sizes, num_samples=1000): result = {} for size in sample_sizes: means = [np.mean(np.random.choice(population, size, replace=False)) for _ in range(num_samples)] result[size] = means return result # ----- Plot Sampling Distributions ----- def plot_sampling_distributions(sampling_distributions, title): for size, means in sampling_distributions.items(): plt.figure(figsize=(6, 3)) sns.histplot(means, kde=True, stat=\"density\") plt.title(f'{title} \u2013 Sample Size {size}') plt.xlabel('Sample Mean') plt.ylabel('Density') plt.grid(True) plt.show() # ----- Plot Variance Shrinkage ----- def plot_variance_change(sampling_distributions, title): sizes = list(sampling_distributions.keys()) variances = [np.var(means) for means in sampling_distributions.values()] plt.figure(figsize=(5, 3)) plt.plot(sizes, variances, marker='o') plt.title(f'Variance of Sample Means \u2013 {title}') plt.xlabel('Sample Size') plt.ylabel('Variance') plt.grid(True) plt.show() # ----- Run Simulations ----- sample_sizes = [5, 10, 30, 50] uniform_samples = simulate_sampling_distribution(pop_uniform, sample_sizes) exp_samples = simulate_sampling_distribution(pop_exponential, sample_sizes) binom_samples = simulate_sampling_distribution(pop_binomial, sample_sizes) # ----- Plot Sampling Distributions ----- plot_sampling_distributions(uniform_samples, \"Uniform Distribution\") plot_sampling_distributions(exp_samples, \"Exponential Distribution\") plot_sampling_distributions(binom_samples, \"Binomial Distribution\") # ----- Plot Variance Shrinkage ----- plot_variance_change(uniform_samples, \"Uniform\") plot_variance_change(exp_samples, \"Exponential\") plot_variance_change(binom_samples, \"Binomial\") 7. Summary and Conclusion The Central Limit Theorem holds regardless of the original population shape \u2014 even if it is skewed or discrete. Symmetric populations (e.g., uniform, binomial) converge to normality faster. Skewed distributions (e.g., exponential) need larger sample sizes for the sample mean distribution to resemble a normal distribution. The standard deviation (spread) of the sample mean shrinks with increasing sample size \u2014 providing more precise estimates. This simulation clearly illustrates the power and universality of the CLT in statistics and real-world applications. My Colab (Canliy961) Central Limit Theorem","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-clt-simulation-and-analysis","text":"","title":"Central Limit Theorem (CLT) \u2013 Simulation and Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-population-distributions-used","text":"We will use three types of distributions to represent different population shapes: Uniform Distribution : All values are equally likely. (Symmetric) Exponential Distribution : Highly right-skewed. (Asymmetric) Binomial Distribution : Discrete distribution counting the number of successes in fixed trials. Each population will consist of a large number of data points (e.g., 100,000 values) to closely approximate a real-world dataset.","title":"1. Population Distributions Used"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-sample-means","text":"From each population, we will: Randomly draw many samples of fixed sizes (e.g., 5, 10, 30, 50). Compute the sample mean for each sample.","title":"2. Sampling and Sample Means"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-is-a-sample-mean","text":"The sample mean (average) of a sample of size \\(n\\) is given by: \\[ \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] \\] We will repeat the sampling process many times (e.g., 1,000 times per sample size) to build a sampling distribution of the sample mean.","title":"What Is a Sample Mean?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-visualization-of-sampling-distributions","text":"We will plot histograms of sample means for each sample size. As the sample size increases: The shape of the sampling distribution becomes more bell-shaped. The distribution gets more concentrated around the true population mean. This visually demonstrates how the CLT works in practice.","title":"3. Visualization of Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-effect-of-sample-size-on-spread","text":"According to the CLT, the variance of the sample mean decreases as the sample size increases: \\[ \\[ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} \\] \\] This means that: Larger samples lead to more consistent and reliable sample means. The spread (standard deviation) of the sampling distribution gets smaller as \\(n\\) increases. We will plot how the variance of the sample means changes with different sample sizes for each distribution.","title":"4. Effect of Sample Size on Spread"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-reflections-and-real-world-applications","text":"Why is the Central Limit Theorem so important?","title":"5. Reflections and Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-estimation","text":"It justifies using sample means to estimate unknown population means. Confidence intervals are based on the assumption of normality of sample means.","title":"Parameter Estimation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#quality-control","text":"In manufacturing, means of product measurements are monitored using control charts, assuming normality.","title":"Quality Control:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#finance-and-economics","text":"Financial returns of diversified portfolios often behave like normal distributions due to the CLT.","title":"Finance and Economics:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hypothesis-testing","text":"Most parametric tests rely on the assumption that the sampling distribution of the test statistic is normal.","title":"Hypothesis Testing:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set seed for reproducibility np.random.seed(42) # ----- Population Generation ----- population_size = 100_000 pop_uniform = np.random.uniform(0, 1, population_size) pop_exponential = np.random.exponential(scale=1.0, size=population_size) pop_binomial = np.random.binomial(n=10, p=0.5, size=population_size) # ----- Plot Population Distribution ----- def plot_population(data, title): plt.figure(figsize=(6, 3)) sns.histplot(data, bins=50, kde=True) plt.title(f'{title} Population') plt.xlabel('Value') plt.ylabel('Frequency') plt.grid(True) plt.show() plot_population(pop_uniform, \"Uniform\") plot_population(pop_exponential, \"Exponential\") plot_population(pop_binomial, \"Binomial\") # ----- Simulate Sampling Distribution ----- def simulate_sampling_distribution(population, sample_sizes, num_samples=1000): result = {} for size in sample_sizes: means = [np.mean(np.random.choice(population, size, replace=False)) for _ in range(num_samples)] result[size] = means return result # ----- Plot Sampling Distributions ----- def plot_sampling_distributions(sampling_distributions, title): for size, means in sampling_distributions.items(): plt.figure(figsize=(6, 3)) sns.histplot(means, kde=True, stat=\"density\") plt.title(f'{title} \u2013 Sample Size {size}') plt.xlabel('Sample Mean') plt.ylabel('Density') plt.grid(True) plt.show() # ----- Plot Variance Shrinkage ----- def plot_variance_change(sampling_distributions, title): sizes = list(sampling_distributions.keys()) variances = [np.var(means) for means in sampling_distributions.values()] plt.figure(figsize=(5, 3)) plt.plot(sizes, variances, marker='o') plt.title(f'Variance of Sample Means \u2013 {title}') plt.xlabel('Sample Size') plt.ylabel('Variance') plt.grid(True) plt.show() # ----- Run Simulations ----- sample_sizes = [5, 10, 30, 50] uniform_samples = simulate_sampling_distribution(pop_uniform, sample_sizes) exp_samples = simulate_sampling_distribution(pop_exponential, sample_sizes) binom_samples = simulate_sampling_distribution(pop_binomial, sample_sizes) # ----- Plot Sampling Distributions ----- plot_sampling_distributions(uniform_samples, \"Uniform Distribution\") plot_sampling_distributions(exp_samples, \"Exponential Distribution\") plot_sampling_distributions(binom_samples, \"Binomial Distribution\") # ----- Plot Variance Shrinkage ----- plot_variance_change(uniform_samples, \"Uniform\") plot_variance_change(exp_samples, \"Exponential\") plot_variance_change(binom_samples, \"Binomial\")","title":"6. Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#7-summary-and-conclusion","text":"The Central Limit Theorem holds regardless of the original population shape \u2014 even if it is skewed or discrete. Symmetric populations (e.g., uniform, binomial) converge to normality faster. Skewed distributions (e.g., exponential) need larger sample sizes for the sample mean distribution to resemble a normal distribution. The standard deviation (spread) of the sample mean shrinks with increasing sample size \u2014 providing more precise estimates. This simulation clearly illustrates the power and universality of the CLT in statistics and real-world applications.","title":"7. Summary and Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#my-colab-canliy961","text":"Central Limit Theorem","title":"My Colab (Canliy961)"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Monte Carlo Estimation of \\(\\pi\\) Monte Carlo simulations are a powerful way to estimate values using randomness. One of the most elegant examples is estimating \\(\\pi\\) through geometric probability. This project explores two classic methods: the circle-based approach and Buffon\u2019s Needle experiment . 1. Circle-Based Method Theoretical Foundation A unit circle is inscribed within a square of side length 2 (extending from -1 to 1 in both \\(x\\) and \\(y\\) directions). We randomly generate points inside the square and calculate the fraction that falls within the circle. Area of the square: \\(4\\) Area of the circle: \\(\\pi\\) The probability a point lands inside the circle is: \\[ P = \\frac{\\text{Area of circle}}{\\text{Area of square}} = \\frac{\\pi}{4} \\] Thus, \\(\\pi\\) can be estimated by: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{points inside the circle}}{\\text{total points}} \\] Convergence Analysis This method has a convergence rate of \\(\\mathcal{O}(1/\\sqrt{n})\\) . To achieve approximately 2 correct decimal digits , we typically need around 10,000 points . Accuracy improves slowly: even with 1,000,000 points , the estimate might only stabilize to 4 correct digits . Visualization Notes Points are plotted with two colors: inside the circle (e.g., blue) and outside (e.g., red). The visual clearly illustrates how the density inside the circle relates to the estimate of \\(\\pi\\) . A convergence graph ( \\(\\pi\\) estimate vs number of points) shows how the estimate fluctuates and stabilizes with more samples. 2. Buffon\u2019s Needle Theoretical Foundation This classical probability problem involves dropping a needle of length \\(L\\) on a plane with equally spaced parallel lines a distance \\(d\\) apart (with \\(L \\leq d\\) ). The probability the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] Rearranged to estimate \\(\\pi\\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: \\(N\\) is the number of throws \\(C\\) is the number of crossings Convergence Analysis This method converges even more slowly than the circle-based method. The estimate is highly variable , especially when crossings are rare (e.g., short needle, few drops). Often requires hundreds of thousands of throws to produce a decent estimate. Still, it's historically significant and a clever geometric trick to estimate \\(\\pi\\) without geometry per se . Visualization Notes The needle's position and orientation are shown relative to the lines. Needles that cross a line are colored differently (e.g., red), offering a clear visual of successful \"hits\". The visual offers intuition into the randomness and rare event behavior that drives this method. 3. Summary Comparison Method Accuracy per 10,000 samples Convergence Rate Notes Circle-Based \u2248 2 decimal digits \\(\\mathcal{O}(1/\\sqrt{n})\\) Simple, stable, and easy to visualize Buffon\u2019s Needle \u2248 1 digit or less Slower, high variance Elegant idea, but inefficient for estimation 4. Python Simulation import numpy as np import matplotlib.pyplot as plt # === Circle-Based Method === def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate, x, y, inside def plot_circle(x, y, inside, num_points, pi_estimate): plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, label=\"Inside Circle\", alpha=0.6) plt.scatter(x[~inside], y[~inside], s=1, label=\"Outside Circle\", alpha=0.6) plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo \u03c0 Estimate ({num_points} points)\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.grid(True) plt.show() def convergence_circle(trials): estimates = [] for n in trials: pi_est, *_ = estimate_pi_circle(n) estimates.append(pi_est) plt.figure(figsize=(8, 5)) plt.plot(trials, estimates, marker='o', linestyle='-', label=\"Estimated \u03c0\") plt.axhline(np.pi, color='red', linestyle='--', label=\"Actual \u03c0\") plt.xscale('log') plt.xlabel(\"Number of Points (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimate (Circle-Based Method)\") plt.legend() plt.grid(True) plt.show() # === Buffon's Needle Method === def estimate_pi_buffon(throws, L=1.0, d=1.0): crossings = 0 positions = [] for _ in range(throws): y = np.random.uniform(0, d / 2) theta = np.random.uniform(0, np.pi / 2) if y <= (L / 2) * np.sin(theta): crossings += 1 positions.append((y, theta)) if crossings == 0: return None, positions pi_estimate = (2 * L * throws) / (d * crossings) return pi_estimate, positions def plot_buffon(positions, pi_estimate, throws, L=1.0, d=1.0): plt.figure(figsize=(6, 6)) for y, theta in positions: y1 = y y2 = y - L * np.sin(theta) x2 = L * np.cos(theta) color = 'red' if y2 <= 0 else 'blue' plt.plot([0, x2], [y1, y2], color=color, alpha=0.5) for i in range(3): plt.axhline(i * d / 2, color='black', linestyle='--', linewidth=1) plt.title(f\"Buffon\u2019s Needle Simulation ({throws} drops)\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.gca().set_aspect('equal') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() def convergence_buffon(trials_list, L=1.0, d=1.0): estimates = [] for n in trials_list: est, _ = estimate_pi_buffon(n, L, d) estimates.append(est if est else np.nan) plt.figure(figsize=(8, 5)) plt.plot(trials_list, estimates, marker='o', linestyle='-', label=\"Estimated \u03c0\") plt.axhline(np.pi, color='red', linestyle='--', label=\"Actual \u03c0\") plt.xscale('log') plt.xlabel(\"Number of Drops (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimate (Buffon\u2019s Needle)\") plt.legend() plt.grid(True) plt.show() # === Example Usage === if __name__ == \"__main__\": # Circle-Based Simulation num_points = 10000 pi_c, x, y, inside = estimate_pi_circle(num_points) plot_circle(x, y, inside, num_points, pi_c) # Circle-Based Convergence circle_trials = [10, 100, 1000, 10000, 100000, 500000] convergence_circle(circle_trials) # Buffon's Needle Simulation throws = 10000 pi_b, positions = estimate_pi_buffon(throws) if pi_b: plot_buffon(positions, pi_b, throws) # Buffon's Needle Convergence buffon_trials = [100, 1000, 5000, 10000, 50000, 100000, 500000] convergence_buffon(buffon_trials) My Colab (Canliy961) Monte Carlo Method","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#monte-carlo-estimation-of-pi","text":"Monte Carlo simulations are a powerful way to estimate values using randomness. One of the most elegant examples is estimating \\(\\pi\\) through geometric probability. This project explores two classic methods: the circle-based approach and Buffon\u2019s Needle experiment .","title":"Monte Carlo Estimation of \\(\\pi\\)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-circle-based-method","text":"","title":"1. Circle-Based Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"A unit circle is inscribed within a square of side length 2 (extending from -1 to 1 in both \\(x\\) and \\(y\\) directions). We randomly generate points inside the square and calculate the fraction that falls within the circle. Area of the square: \\(4\\) Area of the circle: \\(\\pi\\) The probability a point lands inside the circle is: \\[ P = \\frac{\\text{Area of circle}}{\\text{Area of square}} = \\frac{\\pi}{4} \\] Thus, \\(\\pi\\) can be estimated by: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{points inside the circle}}{\\text{total points}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"This method has a convergence rate of \\(\\mathcal{O}(1/\\sqrt{n})\\) . To achieve approximately 2 correct decimal digits , we typically need around 10,000 points . Accuracy improves slowly: even with 1,000,000 points , the estimate might only stabilize to 4 correct digits .","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization-notes","text":"Points are plotted with two colors: inside the circle (e.g., blue) and outside (e.g., red). The visual clearly illustrates how the density inside the circle relates to the estimate of \\(\\pi\\) . A convergence graph ( \\(\\pi\\) estimate vs number of points) shows how the estimate fluctuates and stabilizes with more samples.","title":"Visualization Notes"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-buffons-needle","text":"","title":"2. Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"This classical probability problem involves dropping a needle of length \\(L\\) on a plane with equally spaced parallel lines a distance \\(d\\) apart (with \\(L \\leq d\\) ). The probability the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] Rearranged to estimate \\(\\pi\\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: \\(N\\) is the number of throws \\(C\\) is the number of crossings","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis_1","text":"This method converges even more slowly than the circle-based method. The estimate is highly variable , especially when crossings are rare (e.g., short needle, few drops). Often requires hundreds of thousands of throws to produce a decent estimate. Still, it's historically significant and a clever geometric trick to estimate \\(\\pi\\) without geometry per se .","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization-notes_1","text":"The needle's position and orientation are shown relative to the lines. Needles that cross a line are colored differently (e.g., red), offering a clear visual of successful \"hits\". The visual offers intuition into the randomness and rare event behavior that drives this method.","title":"Visualization Notes"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-summary-comparison","text":"Method Accuracy per 10,000 samples Convergence Rate Notes Circle-Based \u2248 2 decimal digits \\(\\mathcal{O}(1/\\sqrt{n})\\) Simple, stable, and easy to visualize Buffon\u2019s Needle \u2248 1 digit or less Slower, high variance Elegant idea, but inefficient for estimation","title":"3. Summary Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # === Circle-Based Method === def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate, x, y, inside def plot_circle(x, y, inside, num_points, pi_estimate): plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, label=\"Inside Circle\", alpha=0.6) plt.scatter(x[~inside], y[~inside], s=1, label=\"Outside Circle\", alpha=0.6) plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo \u03c0 Estimate ({num_points} points)\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.grid(True) plt.show() def convergence_circle(trials): estimates = [] for n in trials: pi_est, *_ = estimate_pi_circle(n) estimates.append(pi_est) plt.figure(figsize=(8, 5)) plt.plot(trials, estimates, marker='o', linestyle='-', label=\"Estimated \u03c0\") plt.axhline(np.pi, color='red', linestyle='--', label=\"Actual \u03c0\") plt.xscale('log') plt.xlabel(\"Number of Points (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimate (Circle-Based Method)\") plt.legend() plt.grid(True) plt.show() # === Buffon's Needle Method === def estimate_pi_buffon(throws, L=1.0, d=1.0): crossings = 0 positions = [] for _ in range(throws): y = np.random.uniform(0, d / 2) theta = np.random.uniform(0, np.pi / 2) if y <= (L / 2) * np.sin(theta): crossings += 1 positions.append((y, theta)) if crossings == 0: return None, positions pi_estimate = (2 * L * throws) / (d * crossings) return pi_estimate, positions def plot_buffon(positions, pi_estimate, throws, L=1.0, d=1.0): plt.figure(figsize=(6, 6)) for y, theta in positions: y1 = y y2 = y - L * np.sin(theta) x2 = L * np.cos(theta) color = 'red' if y2 <= 0 else 'blue' plt.plot([0, x2], [y1, y2], color=color, alpha=0.5) for i in range(3): plt.axhline(i * d / 2, color='black', linestyle='--', linewidth=1) plt.title(f\"Buffon\u2019s Needle Simulation ({throws} drops)\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.gca().set_aspect('equal') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() def convergence_buffon(trials_list, L=1.0, d=1.0): estimates = [] for n in trials_list: est, _ = estimate_pi_buffon(n, L, d) estimates.append(est if est else np.nan) plt.figure(figsize=(8, 5)) plt.plot(trials_list, estimates, marker='o', linestyle='-', label=\"Estimated \u03c0\") plt.axhline(np.pi, color='red', linestyle='--', label=\"Actual \u03c0\") plt.xscale('log') plt.xlabel(\"Number of Drops (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimate (Buffon\u2019s Needle)\") plt.legend() plt.grid(True) plt.show() # === Example Usage === if __name__ == \"__main__\": # Circle-Based Simulation num_points = 10000 pi_c, x, y, inside = estimate_pi_circle(num_points) plot_circle(x, y, inside, num_points, pi_c) # Circle-Based Convergence circle_trials = [10, 100, 1000, 10000, 100000, 500000] convergence_circle(circle_trials) # Buffon's Needle Simulation throws = 10000 pi_b, positions = estimate_pi_buffon(throws) if pi_b: plot_buffon(positions, pi_b, throws) # Buffon's Needle Convergence buffon_trials = [100, 1000, 5000, 10000, 50000, 100000, 500000] convergence_buffon(buffon_trials)","title":"4. Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#my-colab-canliy961","text":"Monte Carlo Method","title":"My Colab (Canliy961)"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Pendulum Experiment: Measuring Earth's Gravitational Acceleration Experiment: Measuring Acceleration Due to Gravity Using a Phone Charger as a Pendulum Objective To measure the acceleration due to gravity \\(g\\) using a simple pendulum setup made from a phone charger cable and a small object. Materials Needed Phone charger cable (approx. 1 meter or more) Small object as a weight (e.g., metal key, padlock, USB adapter) Ruler or tape measure (1 mm resolution preferred) Smartphone stopwatch or timer Hook, doorknob, or shelf to suspend the pendulum Notebook or notes app to record time Procedure 1. Setup Tie the small object securely to the end of the phone charger. Hang the other end from a fixed support so the object can swing freely. Measure the length \\(L\\) from the suspension point to the center of mass of the object. Example: \\(L = 1.02 \\ \\text{m}\\) Estimate the uncertainty: \\( \\(\\Delta L = \\frac{\\text{ruler resolution}}{2} = \\frac{0.001}{2} = 0.0005 \\ \\text{m}\\) \\) 2. Data Collection Pull the weight back gently (angle < 15\u00b0) and release. Start timing as it swings forward \u2014 count 10 complete oscillations . Repeat this process 10 times, recording each result as \\(T_{10}\\) . Data Table Trial Time for 10 Oscillations \\(T_{10}\\) (s) 1 19.42 2 19.25 3 18.78 4 18.58 5 18.95 6 19.50 7 19.43 8 19.62 9 19.93 10 19.43 What You\u2019ll Calculate 1. Mean time: \\[\\overline{T_{10}} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = 19.389 \\ \\text{s}\\] 2. Standard deviation: \\[\\sigma_T = \\sqrt{\\frac{1}{n-1} \\sum (T_{10,i} - \\overline{T_{10}})^2} \\approx 0.409 \\ \\text{s}\\] 3. Uncertainty in mean time: \\[\\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} = \\frac{0.409}{\\sqrt{10}} \\approx 0.129 \\ \\text{s}\\] 4. Period of one oscillation: \\[T = \\frac{\\overline{T_{10}}}{10} = \\frac{19.389}{10} = 1.9389 \\ \\text{s}\\] 5. Uncertainty in period: \\[\\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.129}{10} = 0.0129 \\ \\text{s}\\] Calculating \\(g\\) Formula: \\[g = \\frac{4\\pi^2 L}{T^2}\\] Substitution: \\[g = \\frac{4\\pi^2 \\cdot 1.02}{(1.9389)^2} \\approx 10.70 \\ \\text{m/s}^2\\] Uncertainty in \\(g\\) Relative uncertainty: \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L} \\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T} \\right)^2}\\) \\) Substituting: \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{0.0005}{1.02} \\right)^2 + \\left(2 \\cdot \\frac{0.0129}{1.9389} \\right)^2} \\approx \\sqrt{2.4 \\times 10^{-7} + 8.9 \\times 10^{-5}} \\approx 9.5 \\times 10^{-3}\\) \\) Absolute uncertainty: \\( \\(\\Delta g \\approx 10.70 \\cdot 0.0095 \\approx 0.10 \\ \\text{m/s}^2\\) \\) Tips for Accuracy Use a video recording to time oscillations and avoid human reaction error. Measure the string length from the pivot to the center of mass of the object. Ensure the charger swings in a single vertical plane , not side-to-side. Final Result (Example) Measured gravitational acceleration: \\( \\(g = 10.70 \\pm 0.10 \\ \\text{m/s}^2\\) \\) This result is slightly higher than the standard value of \\(9.81 \\ \\text{m/s}^2\\) , likely due to timing or amplitude effects. However, it demonstrates how simple tools can yield reasonably accurate results. ANOTHER Materials Used String : 1.00 m Small weight : keychain Stopwatch : smartphone (resolution = 0.01 s) Ruler : resolution = 0.001 m (1 mm) Procedure 1. Measuring Length ( \\(L\\) ) Measured length from suspension point to center of mass of the weight: \\(L = 1.000 \\ \\text{m}\\) Ruler resolution: \\(0.001 \\ \\text{m}\\) Uncertainty in length: \\( \\(\\Delta L = \\frac{0.001}{2} = 0.0005 \\ \\text{m}\\) \\) 2. Time Measurement: 10 Oscillations Trial Time for 10 Oscillations \\(T_{10}\\) (s) 1 20.12 2 20.18 3 20.16 4 20.11 5 20.20 6 20.13 7 20.14 8 20.17 9 20.15 10 20.16 Data Summary Mean time for 10 oscillations: \\( \\(\\overline{T_{10}} = 20.152 \\ \\text{s}\\) \\) Standard deviation: \\( \\(\\sigma_T = 0.027 \\ \\text{s}\\) \\) Uncertainty in mean time: \\( \\(\\Delta T_{10} = \\frac{0.027}{\\sqrt{10}} \\approx 0.0085 \\ \\text{s}\\) \\) Calculations 1. Period and Its Uncertainty Period of one oscillation: \\( \\(T = \\frac{20.152}{10} = 2.0152 \\ \\text{s}\\) \\) Uncertainty in period: \\( \\(\\Delta T = \\frac{0.0085}{10} = 0.00085 \\ \\text{s}\\) \\) 2. Calculating \\(g\\) Using the pendulum formula: \\( \\(g = \\frac{4\\pi^2 L}{T^2}\\) \\) Substitute values: \\( \\(g = \\frac{4\\pi^2 (1.000)}{(2.0152)^2} \\approx 9.719 \\ \\text{m/s}^2\\) \\) 3. Uncertainty in \\(g\\) Relative uncertainty in \\(g\\) : \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L} \\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T} \\right)^2}\\) \\) Substitute values: \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{0.0005}{1.000} \\right)^2 + \\left(2 \\cdot \\frac{0.00085}{2.0152} \\right)^2}\\) \\) \\[\\frac{\\Delta g}{g} \\approx \\sqrt{2.5 \\times 10^{-7} + 7.1 \\times 10^{-7}} \\approx 9.6 \\times 10^{-7}\\] Absolute uncertainty in \\(g\\) : \\( \\(\\Delta g \\approx 0.00098 \\cdot 9.719 \\approx 0.0095 \\ \\text{m/s}^2\\) \\) Final Results Quantity Value Length \\(L\\) \\(1.000 \\ \\text{m}\\) Uncertainty \\(\\Delta L\\) \\(0.0005 \\ \\text{m}\\) Mean \\(T_{10}\\) \\(20.152 \\ \\text{s}\\) Std Dev \\(\\sigma_T\\) \\(0.027 \\ \\text{s}\\) Uncertainty \\(\\Delta T_{10}\\) \\(0.0085 \\ \\text{s}\\) Period \\(T\\) \\(2.0152 \\ \\text{s}\\) Uncertainty \\(\\Delta T\\) \\(0.00085 \\ \\text{s}\\) Calculated \\(g\\) \\(9.719 \\ \\text{m/s}^2\\) Uncertainty \\(\\Delta g\\) \\(\\pm 0.010 \\ \\text{m/s}^2\\) Discussion 1. Comparison with Standard \\(g = 9.81 \\ \\text{m/s}^2\\) Measured value: \\(g = 9.719 \\pm 0.010 \\ \\text{m/s}^2\\) Difference: \\(9.81 - 9.719 = 0.091 \\ \\text{m/s}^2\\) Percentage error: \\( \\(\\frac{0.091}{9.81} \\times 100\\% \\approx 0.93\\%\\) \\) The result is within 0.9% of the standard value \u2014 reasonably accurate. 2. Uncertainty Sources and Impact Length Measurement ( \\(\\Delta L\\) ) : Very small due to high ruler resolution \u2014 negligible effect. Timing Uncertainty ( \\(\\Delta T\\) ) : Main contributor to error. Human reaction time (~0.1s) is reduced by averaging over 10 oscillations. Assumptions: Small-angle approximation (<15\u00b0) holds. No air resistance or friction considered. Mass of the string is negligible. Conclusion This experiment effectively measures the gravitational acceleration with decent accuracy. The dominant uncertainty arises from timing, reinforcing the importance of reducing human error through averaging and repeat trials. My Colab (Canliy961) Measurements","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#pendulum-experiment-measuring-earths-gravitational-acceleration","text":"","title":"Pendulum Experiment: Measuring Earth's Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experiment-measuring-acceleration-due-to-gravity-using-a-phone-charger-as-a-pendulum","text":"","title":"Experiment: Measuring Acceleration Due to Gravity Using a Phone Charger as a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"To measure the acceleration due to gravity \\(g\\) using a simple pendulum setup made from a phone charger cable and a small object.","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials-needed","text":"Phone charger cable (approx. 1 meter or more) Small object as a weight (e.g., metal key, padlock, USB adapter) Ruler or tape measure (1 mm resolution preferred) Smartphone stopwatch or timer Hook, doorknob, or shelf to suspend the pendulum Notebook or notes app to record time","title":"Materials Needed"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-setup","text":"Tie the small object securely to the end of the phone charger. Hang the other end from a fixed support so the object can swing freely. Measure the length \\(L\\) from the suspension point to the center of mass of the object. Example: \\(L = 1.02 \\ \\text{m}\\) Estimate the uncertainty: \\( \\(\\Delta L = \\frac{\\text{ruler resolution}}{2} = \\frac{0.001}{2} = 0.0005 \\ \\text{m}\\) \\)","title":"1. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-data-collection","text":"Pull the weight back gently (angle < 15\u00b0) and release. Start timing as it swings forward \u2014 count 10 complete oscillations . Repeat this process 10 times, recording each result as \\(T_{10}\\) .","title":"2. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-table","text":"Trial Time for 10 Oscillations \\(T_{10}\\) (s) 1 19.42 2 19.25 3 18.78 4 18.58 5 18.95 6 19.50 7 19.43 8 19.62 9 19.93 10 19.43","title":"Data Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#what-youll-calculate","text":"","title":"What You\u2019ll Calculate"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-mean-time","text":"\\[\\overline{T_{10}} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = 19.389 \\ \\text{s}\\]","title":"1. Mean time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-standard-deviation","text":"\\[\\sigma_T = \\sqrt{\\frac{1}{n-1} \\sum (T_{10,i} - \\overline{T_{10}})^2} \\approx 0.409 \\ \\text{s}\\]","title":"2. Standard deviation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-in-mean-time","text":"\\[\\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} = \\frac{0.409}{\\sqrt{10}} \\approx 0.129 \\ \\text{s}\\]","title":"3. Uncertainty in mean time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-period-of-one-oscillation","text":"\\[T = \\frac{\\overline{T_{10}}}{10} = \\frac{19.389}{10} = 1.9389 \\ \\text{s}\\]","title":"4. Period of one oscillation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-uncertainty-in-period","text":"\\[\\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.129}{10} = 0.0129 \\ \\text{s}\\]","title":"5. Uncertainty in period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculating-g","text":"","title":"Calculating \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#formula","text":"\\[g = \\frac{4\\pi^2 L}{T^2}\\]","title":"Formula:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#substitution","text":"\\[g = \\frac{4\\pi^2 \\cdot 1.02}{(1.9389)^2} \\approx 10.70 \\ \\text{m/s}^2\\]","title":"Substitution:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"Relative uncertainty: \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L} \\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T} \\right)^2}\\) \\) Substituting: \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{0.0005}{1.02} \\right)^2 + \\left(2 \\cdot \\frac{0.0129}{1.9389} \\right)^2} \\approx \\sqrt{2.4 \\times 10^{-7} + 8.9 \\times 10^{-5}} \\approx 9.5 \\times 10^{-3}\\) \\) Absolute uncertainty: \\( \\(\\Delta g \\approx 10.70 \\cdot 0.0095 \\approx 0.10 \\ \\text{m/s}^2\\) \\)","title":"Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#tips-for-accuracy","text":"Use a video recording to time oscillations and avoid human reaction error. Measure the string length from the pivot to the center of mass of the object. Ensure the charger swings in a single vertical plane , not side-to-side.","title":"Tips for Accuracy"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result-example","text":"Measured gravitational acceleration: \\( \\(g = 10.70 \\pm 0.10 \\ \\text{m/s}^2\\) \\) This result is slightly higher than the standard value of \\(9.81 \\ \\text{m/s}^2\\) , likely due to timing or amplitude effects. However, it demonstrates how simple tools can yield reasonably accurate results.","title":"Final Result (Example)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#another-materials-used","text":"String : 1.00 m Small weight : keychain Stopwatch : smartphone (resolution = 0.01 s) Ruler : resolution = 0.001 m (1 mm)","title":"ANOTHER Materials Used"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure_1","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-measuring-length-l","text":"Measured length from suspension point to center of mass of the weight: \\(L = 1.000 \\ \\text{m}\\) Ruler resolution: \\(0.001 \\ \\text{m}\\) Uncertainty in length: \\( \\(\\Delta L = \\frac{0.001}{2} = 0.0005 \\ \\text{m}\\) \\)","title":"1. Measuring Length (\\(L\\))"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-time-measurement-10-oscillations","text":"Trial Time for 10 Oscillations \\(T_{10}\\) (s) 1 20.12 2 20.18 3 20.16 4 20.11 5 20.20 6 20.13 7 20.14 8 20.17 9 20.15 10 20.16","title":"2. Time Measurement: 10 Oscillations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-summary","text":"Mean time for 10 oscillations: \\( \\(\\overline{T_{10}} = 20.152 \\ \\text{s}\\) \\) Standard deviation: \\( \\(\\sigma_T = 0.027 \\ \\text{s}\\) \\) Uncertainty in mean time: \\( \\(\\Delta T_{10} = \\frac{0.027}{\\sqrt{10}} \\approx 0.0085 \\ \\text{s}\\) \\)","title":"Data Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-and-its-uncertainty","text":"Period of one oscillation: \\( \\(T = \\frac{20.152}{10} = 2.0152 \\ \\text{s}\\) \\) Uncertainty in period: \\( \\(\\Delta T = \\frac{0.0085}{10} = 0.00085 \\ \\text{s}\\) \\)","title":"1. Period and Its Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-calculating-g","text":"Using the pendulum formula: \\( \\(g = \\frac{4\\pi^2 L}{T^2}\\) \\) Substitute values: \\( \\(g = \\frac{4\\pi^2 (1.000)}{(2.0152)^2} \\approx 9.719 \\ \\text{m/s}^2\\) \\)","title":"2. Calculating \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-in-g","text":"Relative uncertainty in \\(g\\) : \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L} \\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T} \\right)^2}\\) \\) Substitute values: \\( \\(\\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{0.0005}{1.000} \\right)^2 + \\left(2 \\cdot \\frac{0.00085}{2.0152} \\right)^2}\\) \\) \\[\\frac{\\Delta g}{g} \\approx \\sqrt{2.5 \\times 10^{-7} + 7.1 \\times 10^{-7}} \\approx 9.6 \\times 10^{-7}\\] Absolute uncertainty in \\(g\\) : \\( \\(\\Delta g \\approx 0.00098 \\cdot 9.719 \\approx 0.0095 \\ \\text{m/s}^2\\) \\)","title":"3. Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-results","text":"Quantity Value Length \\(L\\) \\(1.000 \\ \\text{m}\\) Uncertainty \\(\\Delta L\\) \\(0.0005 \\ \\text{m}\\) Mean \\(T_{10}\\) \\(20.152 \\ \\text{s}\\) Std Dev \\(\\sigma_T\\) \\(0.027 \\ \\text{s}\\) Uncertainty \\(\\Delta T_{10}\\) \\(0.0085 \\ \\text{s}\\) Period \\(T\\) \\(2.0152 \\ \\text{s}\\) Uncertainty \\(\\Delta T\\) \\(0.00085 \\ \\text{s}\\) Calculated \\(g\\) \\(9.719 \\ \\text{m/s}^2\\) Uncertainty \\(\\Delta g\\) \\(\\pm 0.010 \\ \\text{m/s}^2\\)","title":"Final Results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison-with-standard-g-981-textms2","text":"Measured value: \\(g = 9.719 \\pm 0.010 \\ \\text{m/s}^2\\) Difference: \\(9.81 - 9.719 = 0.091 \\ \\text{m/s}^2\\) Percentage error: \\( \\(\\frac{0.091}{9.81} \\times 100\\% \\approx 0.93\\%\\) \\) The result is within 0.9% of the standard value \u2014 reasonably accurate.","title":"1. Comparison with Standard \\(g = 9.81 \\ \\text{m/s}^2\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-uncertainty-sources-and-impact","text":"Length Measurement ( \\(\\Delta L\\) ) : Very small due to high ruler resolution \u2014 negligible effect. Timing Uncertainty ( \\(\\Delta T\\) ) : Main contributor to error. Human reaction time (~0.1s) is reduced by averaging over 10 oscillations. Assumptions: Small-angle approximation (<15\u00b0) holds. No air resistance or friction considered. Mass of the string is negligible.","title":"2. Uncertainty Sources and Impact"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This experiment effectively measures the gravitational acceleration with decent accuracy. The dominant uncertainty arises from timing, reinforcing the importance of reducing human error through averaging and repeat trials.","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#my-colab-canliy961","text":"Measurements","title":"My Colab (Canliy961)"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}